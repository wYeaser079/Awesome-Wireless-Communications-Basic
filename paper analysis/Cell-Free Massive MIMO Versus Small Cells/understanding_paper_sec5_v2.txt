
╭─── Claude Code v2.1.63 ──────────────────────────────────────────────────────╮
│                                                    │ Tips for getting        │
│             Welcome back Tech Shottify!            │ started                 │
│                                                    │ Run /init to create a … │
│                       ▐▛███▜▌                      │ ─────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity         │
│                        ▘▘ ▝▝                       │ No recent activity      │
│                                                    │                         │
│               Opus 4.6 · Claude Max                │                         │
│ F:\Codes\Awesome-Wireless-Communications-Paper-Im… │                         │
╰──────────────────────────────────────────────────────────────────────────────╯

❯ I want you to implement this paper:                                       
   CATEGORY A: Core Cell-Free MIMO — Foundations (6 Papers)                 
                                                                            
    ---                                                                     
    Paper 1 — THE Founding Paper                                            
                                                                            
    "Cell-Free Massive MIMO Versus Small Cells"                             
                                                                            
    ┌────────────────┬───────────────────────────────────────────────────── 
  ───┐                                                                      
    │                │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Authors        │ H. Q. Ngo, A. Ashikhmin, H. Yang, E. G. Larsson, T.  
  L. │                                                                      
    │                │  Marzetta                                            
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Journal        │ IEEE Trans. Wireless Commun. (Q1, IF: 10.7)          
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Year /         │ 2017 / ~1,500+                                       
     │                                                                      
    │ Citations      │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ In your        │ Yes                                                  
     │                                                                      
    │ folder?        │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Code           │ https://arxiv.org/abs/1602.08232                     
     │                                                                      
    └────────────────┴───────────────────────────────────────────────────── 
  ───┘                                                                      
                                                                            
    What you'll reproduce: System model with distributed single-antenna     
  APs, TDD                                                                  
    protocol, conjugate beamforming (CB) uplink/downlink, max-min power     
  control,                                                                  
    CDF of per-user throughput vs. small cells.                             
                                                                            
    What you'll learn: The entire CF-mMIMO system model from scratch —      
  channel                                                                   
    estimation, pilot contamination, coherent transmission, favorable       
  propagation,                                                              
     and why cell-free eliminates cell edges.                               
                                                                            
  -----------------------                                                   
  For this, first, you need to read this paper:                             
  F:\Codes\Awesome-Wireless-Communications-Paper-Implementation\papers\Cell 
  -Free\001_All Paper(without review paper)\Cell-Free Massive MIMO Versus   
  Small Cells.pdf                                                           
  ---------------------                                                     
  First, you need to read the pdf.                                          
  and give me a very high level overview without any code summerizing the   
  key contribution of the each sections of the paper.                       
  ------------------                                                        
  After that , we will deep dive in each section and finally we will        
  implement these in Matlab code.                                           
  Make sure you understand the figure very well.                            

● Let me read the paper first.

● Read 1 file (ctrl+o to expand)

● Bash(which pdftoppm 2>/dev/null; which pdftotext 2>/dev/null; pip show PyPDF2
      2>/dev/null | head -2; pip show pymupdf 2>/dev/null | head -2; python -c
      "import fitz;…)
  ⎿  Error: Exit code 1
     /mingw64/bin/pdftotext

     /mingw64/bin/pdftotext

● Bash(pdftotext "F:/Codes/Awesome-Wireless-Communications-Paper-Implementation/
      papers/Cell-Free/001_All Paper(without review paper)/Cell-Free Massive
      MIMO Versus Smal…)
  ⎿  IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. XX, NO. X, XXX 2017

     1
     … +426 lines (ctrl+o to expand)

● Read 2 files (ctrl+o to expand)

● Now I have a thorough understanding of the entire paper. Let me provide the
  high-level overview.

  ---
  Paper Overview: "Cell-Free Massive MIMO versus Small Cells" (Ngo et al., 2017)

  The Big Idea (Abstract)

  Instead of having a few powerful base stations (each creating "cells"),
  scatter hundreds of simple single-antenna access points (APs) across a wide
  area. All APs cooperate phase-coherently through a central processing unit
  (CPU) to serve a much smaller number of users simultaneously on the same 
  time-frequency resource. There are no cells, no cell boundaries — hence
  "Cell-Free."

  The key result: Cell-Free Massive MIMO provides ~5x improvement in 95%-likely
  per-user throughput over small cells (uncorrelated shadowing), and ~10x 
  improvement under correlated shadowing.

  ---
  Section-by-Section Breakdown

  Section I: Introduction

  Key Contribution: Sets up the motivation — why go cell-free?

  - Collocated Massive MIMO (all antennas at one base station) works well, but
  users at cell edges still suffer.
  - Distributed Massive MIMO (spread antennas out) can exploit macro-diversity
  against shadow fading — users are always close to some AP.
  - Prior works on distributed MIMO / network MIMO assumed perfect CSI
  (unrealistic). This paper is the first to rigorously analyze Cell-Free Massive
   MIMO with imperfect CSI, pilot contamination, and optimal power control.
  - The paper distinguishes itself from CoMP/DAS by operating in the Massive 
  MIMO regime: M APs >> K users, with simple conjugate beamforming.

  ---
  Section II: Cell-Free Massive MIMO System Model

  Key Contribution: Defines the complete system architecture.

  - M APs, K users, all single-antenna, randomly distributed in a D x D km area.
  - All APs connect to a CPU via backhaul.
  - TDD protocol with 3 phases per coherence interval:
    a. Uplink training (users send pilots to APs)
    b. Downlink data (APs beamform to users)
    c. Uplink data (users transmit, APs detect)
  - Channel model: g_mk = sqrt(beta_mk) * h_mk where beta_mk = large-scale
  fading, h_mk ~ CN(0,1) = small-scale fading.
  - Section II-A (Uplink Training): Users send pilot sequences of length tau_cf.
   MMSE channel estimation is derived. If tau_cf < K, pilots must be reused →
  pilot contamination. The key estimate formula is g_hat_mk = c_mk * y_{p,mk}
  where c_mk depends on all large-scale fading coefficients of users sharing the
   same pilot.
  - Section II-B (Downlink Data): APs use conjugate beamforming — each AP simply
   multiplies the data symbol by the conjugate of its channel estimate. No CSI
  sharing between APs. Users do not need downlink pilots because of channel 
  hardening (the effective channel gain concentrates around its mean).
  - Section II-C (Uplink Data): Each AP applies matched filtering (multiply
  received signal by conjugate of channel estimate) and forwards the result to
  the CPU for detection.

  ---
  Section III: Performance Analysis

  Key Contribution: Derives exact closed-form rate expressions.

  - Section III-A (Large-M Analysis): When M → ∞, by Tchebyshev's theorem, the
  effects of noise, non-coherent interference, and small-scale fading all 
  vanish. Only pilot contamination remains (interference from users sharing the
  same pilot). This is the "favorable propagation" phenomenon.
  - Section III-B (Finite-M Achievable Rates):
    - Theorem 1 (Downlink Rate): Closed-form SINR expression for any finite M,
  K. The numerator has the squared sum of sqrt(eta_mk) * gamma_mk, and the
  denominator captures beamforming uncertainty + multi-user interference +
  noise. This is Eq. (24) — the central equation of the paper.
    - Theorem 2 (Uplink Rate): Similar closed-form for uplink, Eq. (27). The
  uplink has simpler power control (only K coefficients eta_k vs. M×K for
  downlink).
    - Remark 4 / Figure 2: Shows that the gap between "user knows only
  statistics" vs. "user knows actual channel" is small — confirming channel 
  hardening makes downlink pilots unnecessary.

  ---
  Section IV: Pilot Assignment and Power Control

  Key Contribution: Algorithms for resource management.

  - Section IV-A (Greedy Pilot Assignment):
    - Start with random assignment of tau_cf orthogonal pilots to K users.
    - Iteratively find the worst-rate user, re-assign its pilot to minimize
  pilot contamination (measured by summing large-scale fading of co-pilot users
  across all APs).
    - Simple, effective, runs on large-scale fading timescale (infrequent
  updates).
  - Section IV-B (Max-Min Power Control):
    - Downlink (Algorithm 2): Find power coefficients eta_mk (M×K variables) to
  maximize the minimum user rate. The problem is quasi-concave → solved by
  bisection + SOCP (second-order cone program). Globally optimal.
    - Uplink: Find eta_k (K variables) to maximize the minimum user rate. The
  problem is quasi-linear → solved by bisection + linear program. Even simpler.
    - Max-min fairness ensures uniformly good service — no user is left behind
  regardless of location.

  ---
  Section V: Small-Cell System (Baseline)

  Key Contribution: Defines the comparison baseline.

  - Each user is served by only one AP (the one with best large-scale fading).
  No cooperation between APs.
  - Unlike Cell-Free, there is no channel hardening (single Rayleigh fading
  scalar), so both uplink and downlink pilots are needed.
  - Achievable rate is expressed using the exponential integral function Ei(·),
  Eq. (43) and (47).
  - Max-min power control is also quasi-linear → solvable by bisection.
  - Fair comparison: total radiated power is kept equal (rho_sc = (M/K) * 
  rho_cf).

  ---
  Section VI: Numerical Results

  Key Contribution: Quantitative comparison via CDF plots.

  Setup: M=100 APs, K=40 users, 1km × 1km area, 1.9 GHz carrier, 20 MHz
  bandwidth, coherence interval = 200 samples. The area wraps around (toroidal)
  to avoid boundary effects.

  Key Figures:

  ┌────────┬────────────────────────────────────────────────────────────────┐
  │ Figure │                         What it shows                          │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 2 │ Rate vs. M: validates channel hardening (statistics-only vs.   │
  │        │ genie-aided)                                                   │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │        │ CDF of DL throughput (greedy pilot + max-min power control):   │
  │ Fig. 3 │ CF-mMIMO 95%-likely ≈ 14 Mbps vs. small-cell ≈ 2 Mbps          │
  │        │ (uncorrelated); gap widens with correlated shadowing           │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 4 │ Same as Fig. 3 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 5 │ CDF of DL throughput without power control: CF still better,   │
  │        │ but the CDF is much more spread out                            │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 6 │ Same as Fig. 5 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 7 │ CDF with random pilot assignment + max-min PC: ~20% worse than │
  │        │  greedy at 95%-likely                                          │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 8 │ Same as Fig. 7 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 9 │ Effective number of APs per user: only ~10-20 out of 100 APs   │
  │        │ contribute 95% of the power                                    │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig.   │ Avg DL throughput vs. K (number of users)                      │
  │ 10     │                                                                │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig.   │ Avg DL throughput vs. M (number of APs)                        │
  │ 11     │                                                                │
  └────────┴────────────────────────────────────────────────────────────────┘

  Key takeaways from figures:
  1. Power control is far more important than pilot assignment (factor of ~2.5x
  improvement at 95%-likely).
  2. Greedy pilot assignment gives ~20% gain over random.
  3. Cell-Free is robust to correlated shadowing; small-cell is devastated by
  it.
  4. Even though 100 APs exist, only ~10-20 effectively serve each user (natural
   sparsity).

  ---
  Section VII: Conclusion

  - Cell-Free Massive MIMO massively outperforms small cells.
  - Shadow fading correlation hurts small cells far more than Cell-Free.
  - The trade-off: Cell-Free requires more backhaul than small cells.

  Appendix A & B

  - Appendix A: Full proof of Theorem 1 (downlink rate) — derives DS, BU, and UI
   terms step by step.
  - Appendix B: Proves that the downlink max-min problem is quasi-concave,
  enabling the bisection approach.

  ---
  Summary of What We'll Implement

  ┌─────────────────────┬───────────────────────────────────────────────────┐
  │      Component      │                    Description                    │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Channel generation  │ Large-scale fading (3-slope path loss +           │
  │                     │ log-normal shadowing, correlated & uncorrelated)  │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ MMSE channel        │ With pilot contamination                          │
  │ estimation          │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Conjugate           │ Distributed precoding at each AP                  │
  │ beamforming (DL)    │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Matched filtering   │ Distributed detection at each AP                  │
  │ (UL)                │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Closed-form rate    │ Theorems 1 & 2, Eqs. (24) and (27)                │
  │ computation         │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Greedy pilot        │ Algorithm 1                                       │
  │ assignment          │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Max-min power       │ DL: bisection + SOCP; UL: bisection + LP          │
  │ control             │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Small-cell baseline │ AP selection, rate expressions with Ei(·), power  │
  │                     │ control                                           │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ CDF generation      │ Reproduce Figures 3-11                            │
  └─────────────────────┴───────────────────────────────────────────────────┘

  ---
  Whenever you're ready, we can deep-dive into any section and start the MATLAB
  implementation. Where would you like to begin?

✻ Crunched for 1m 55s

❯ Let's deep dive into Section II first.                                    
  You will explain in as much detailed possible. For mathematical           
  explanation, use unicode mathematical notation so that it renders         
  properly on terminal.                                                     
  Try to follow this structure.                                             
  First give a high level explanation with easy and understandable terms.   
  Then, deep dive and explain in details and if possible give mathematical  
  examples.                                                                 
  You should provide your response in 4 chunks.                             
  1st chunk --> explain initial discussion on system model                  
  2nd chunk --> Uplink training                                             
  3rd chunk --> Downlink Payload data transmission                          
  4th chunk --> Uplink Payload data transmission                            
  ---------------------                                                     
  Do deep research on the web, IEEE site, different relevant blog sites and 
   articles available on web.                                               
  Double check and verify before providing your final response so that      
  there is no scope for error.                                              

● I'll do thorough research first, then give you the deep dive. Let me gather
  resources from the web and re-read the paper section carefully.

● 2 Agent agents finished (ctrl+o to expand)
   ├─ Research CF-mMIMO system model · 58 tool uses · 63.9k tokens
   │  ⎿  Done
   └─ Research MMSE estimation details · 57 tool uses · 49.0k tokens
      ⎿  Done

● Excellent. Now I have thorough research. Let me give you the full deep dive.

  ---
  SECTION II: Cell-Free Massive MIMO System Model — Complete Deep Dive

  ---
  CHUNK 1: System Architecture & Channel Model

  1.1 The High-Level Picture (Simple Terms)

  Imagine a big park (1 km × 1 km). Instead of placing one tall cell tower in
  the middle, you scatter 100 tiny lamp-post-mounted antennas (Access Points /
  APs) all over the park. Now 40 people (users) walk around with phones. Every 
  single AP talks to every single user at the same time, on the same frequency.
  There are no "cells", no boundaries, no "edge of coverage." A user standing
  anywhere is always near some APs.

  All these APs are connected by cables (backhaul) to a Central Processing Unit 
  (CPU) — a server room that coordinates everything. But here's the key
  constraint: the APs do NOT share their fast-changing channel measurements with
   each other. Each AP estimates channels on its own and does its own signal
  processing locally. Only the data symbols and slowly-changing power control
  coefficients travel over the backhaul.

  1.2 Formal System Setup

  The system has:

  M = number of Access Points (e.g., 100)
  K = number of users         (e.g., 40)

  Both APs and users have a single antenna each. All M APs simultaneously serve
  all K users on the same time-frequency resource. The operating regime is M ≫ K
   (many more APs than users), which is the hallmark of the Massive MIMO
  paradigm.

  1.3 TDD Protocol — The Three Phases

  The wireless channel changes over time and frequency. It stays approximately
  constant over a block called the coherence interval, of length:

  τ_c = (coherence time) × (coherence bandwidth)   [in samples]

  For example, with coherence time = 1 ms and coherence bandwidth = 200 kHz:

  τ_c = 200 samples

  Each coherence interval is split into three phases:

  ┌─────────────────────────────────────────────────────┐
  │              One Coherence Interval (τ_c)           │
  ├──────────────┬──────────────────┬───────────────────-┤
  │  Phase 1:    │   Phase 2:       │   Phase 3:         │
  │  Uplink      │   Downlink       │   Uplink           │
  │  Training    │   Data TX        │   Data TX          │
  │  (τ_cf)      │                  │                    │
  └──────────────┴──────────────────┴────────────────────┘

  Phase 1 — Uplink Training (τ_cf samples): Users send known pilot sequences to
  the APs. Each AP uses these to estimate the channel to every user. Because of
  TDD reciprocity (uplink channel = downlink channel), this one set of estimates
   works for both directions.

  Phase 2 — Downlink Data (remaining samples, shared with Phase 3): APs use
  their channel estimates to beamform data to users. Users do NOT need to
  estimate the downlink channel (thanks to channel hardening — explained later).

  Phase 3 — Uplink Data: Users transmit data. APs detect using their channel
  estimates.

  Why TDD and not FDD? In FDD, uplink and downlink use different frequencies, so
   the channels are different. Users would need to estimate the downlink channel
   and feed it back — a massive overhead with 100 APs. TDD exploits reciprocity:
   estimate once on the uplink, use for both.

  1.4 The Channel Model — Equation (1)

  The channel coefficient between the m-th AP and the k-th user is:

  g_mk = √β_mk · h_mk                                    ... (1)

  This is a product of two independent effects:

  (a) Large-scale fading: β_mk (deterministic, slowly changing)

  This captures path loss (signal weakens with distance) and shadow fading
  (random blockage by buildings/trees). It depends on:
  - The distance d_mk between AP m and user k
  - The random shadowing environment

  β_mk changes very slowly — constant for ~40 coherence intervals (seconds). It
  is assumed known at both the AP and the CPU (estimated from long-term
  averaging of received signal strength).

  Critical difference from collocated Massive MIMO: In collocated systems, all M
   antennas are at the same base station, so β_mk = β_k for all m (same
  distance). In Cell-Free, every AP-user pair has a different β_mk because the
  APs are spread out. This is what makes the analysis and power control
  fundamentally different.

  (b) Small-scale fading: h_mk (random, changes every coherence interval)

  h_mk ~ CN(0, 1)     (i.i.d. complex Gaussian, zero mean, unit variance)

  This is Rayleigh fading — modeling multipath propagation (signal bouncing off
  scatterers). Key properties:

  - Independent across all (m, k) pairs. Why? APs and users are far apart from
  each other, so the scattering environments are different.
  - Changes every coherence interval — must be re-estimated each time.
  - |h_mk|² ~ Exponential(1), so E{|h_mk|²} = 1.

  Numerical Example

  Suppose AP₃ is 200m away from User₅. The path loss gives β₃₅ = 10⁻⁹·⁵ (≈ −95
  dB). The small-scale fading in this coherence interval happens to be h₃₅ = 0.7
   + 0.4j. Then:

  g₃₅ = √(10⁻⁹·⁵) · (0.7 + 0.4j) ≈ 1.78×10⁻⁵ · (0.7 + 0.4j)

  Meanwhile, AP₇ is only 30m from User₅, so β₇₅ = 10⁻⁷ (≈ −70 dB), and:

  g₇₅ = √(10⁻⁷) · h₇₅ ≈ 3.16×10⁻⁴ · h₇₅

  AP₇'s channel is ~18× stronger than AP₃'s, simply because it's closer. This
  distance-dependent variation is the essence of the distributed architecture.

  1.5 Key Assumptions (Summarized)

  ┌──────────────────────────────────────┬──────────────────────────────────┐
  │              Assumption              │          Justification           │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Single antenna at each AP and user   │ Simplicity; multi-antenna is     │
  │                                      │ future work                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ h_mk ~ i.i.d. CN(0,1)                │ APs/users spread out → different │
  │                                      │  scatterers                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ β_mk known a priori                  │ Changes slowly, can be tracked   │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Perfect backhaul (infinite capacity, │ Idealized; practical constraints │
  │  no errors)                          │  are future work                 │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Channel reciprocity (uplink =        │ Requires TDD + hardware          │
  │ downlink)                            │ calibration                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Symbols q_k are i.i.d., independent  │ Standard assumption              │
  │ of channels/noise                    │                                  │
  └──────────────────────────────────────┴──────────────────────────────────┘

  1.6 Figure 1 — System Architecture

          ┌─────────┐
          │   CPU   │  ← Central Processing Unit
          └────┬────┘
               │ Backhaul (payload data + power control coefficients)
       ┌───────┼───────┬───────────┐
       │       │       │           │
     ┌─┴─┐  ┌─┴─┐  ┌──┴──┐   ┌──┴──┐
     │AP₁│  │AP₂│  │AP_m │   │AP_M │    ← M single-antenna APs
     └─┬─┘  └─┬─┘  └──┬──┘   └──┬──┘
       │╲      │╲      │╲        │╲       g_mk = channel coefficient
       │  ╲    │  ╲    │  ╲      │  ╲
     ┌─┴─┐ ┌──┴──┐ ┌──┴──┐  ┌──┴──┐
     │UE₁│ │UE_k │ │UE_k'│  │UE_K │    ← K single-antenna users
     └───┘ └─────┘ └─────┘  └─────┘

  What travels over the backhaul:
  - Payload data symbols (encoded/decoded at CPU)
  - Power control coefficients (change on large-scale fading timescale)

  What does NOT travel over the backhaul:
  - Instantaneous channel estimates (stay local at each AP)
  - Raw received signals (processed locally)

  This is the key architectural choice that makes Cell-Free Massive MIMO
  scalable.

  ---
  CHUNK 2: Uplink Training — Channel Estimation & Pilot Contamination

  2.1 The High-Level Picture

  Before the APs can serve the users, they need to know the channels. So the
  users send known "pilot" signals. Each AP listens, and from these known
  signals, figures out the channel to each user. This is like shining a
  flashlight in a foggy room — from how the known light pattern arrives, you can
   infer the properties of the fog (the channel).

  The problem: with τ_cf pilot samples, you can only create τ_cf mutually
  orthogonal pilot sequences. If K > τ_cf, some users must share the same pilot.
   When two users share a pilot, the AP cannot tell their channels apart — this
  is pilot contamination, the fundamental bottleneck of Massive MIMO.

  2.2 Pilot Sequences

  Let φ_k ∈ ℂ^{τ_cf × 1} be the pilot sequence used by the k-th user, with:

  ‖φ_k‖² = 1     (unit norm, normalized)

  There exist exactly τ_cf mutually orthogonal pilot sequences. If τ_cf ≥ K,
  each user gets a unique orthogonal pilot (φ_k^H φ_i = 0 for k ≠ i). If τ_cf <
  K (the typical case), some users must reuse pilots:

  φ_k^H φ_i = { 1   if users k and i share the same pilot
               { 0   otherwise

  2.3 Received Pilot Signal at AP m — Equation (2)

  During uplink training, all K users simultaneously transmit their pilot
  sequences. The received τ_cf × 1 vector at the m-th AP is:

                     K
  y_{p,m} = √(τ_cf · ρ_cf) · Σ  g_mk · φ_k^H  +  w_{p,m}          ... (2)
                    k=1

  where:
  - ρ_cf = normalized SNR of each pilot symbol (= pilot power / noise power)
  - g_mk = channel coefficient (what we want to estimate)
  - φ_k^H = Hermitian (conjugate transpose) of user k's pilot — a 1 × τ_cf row
  vector
  - w_{p,m} ~ CN(0, I_{τ_cf}) = additive noise at AP m (each element is i.i.d.
  CN(0,1))

  Dimensions check: g_mk is scalar, φ_k^H is 1 × τ_cf, so g_mk · φ_k^H is 1 ×
  τ_cf. We're summing K such terms, getting a 1 × τ_cf vector. With the noise,
  y_{p,m} is also τ_cf × 1 (taking transpose appropriately).

  Physical meaning: Each row of y_{p,m} is one time sample at AP m. The AP hears
   a superposition of all K users' pilots, each scaled by their respective
  channel.

  2.4 Projection onto Pilot of User k — Equation (3)

  To extract information about g_mk, the AP projects the received signal onto
  user k's pilot φ_k:

  ŷ_{p,mk} = φ_k^H · y_{p,m}

  Substituting Eq. (2):

                                        K
  ŷ_{p,mk} = √(τ_cf · ρ_cf) · g_mk + √(τ_cf · ρ_cf) · Σ   g_mk' · φ_k'^H · φ_k
  +  φ_k^H · w_{p,m}
                                       k'≠k

            = √(τ_cf · ρ_cf) · g_mk  +  √(τ_cf · ρ_cf) · Σ   g_mk' · φ_k'^H ·
  φ_k   +  w̃_{p,mk}
                                                           k'≠k
                     ... (3)

  where w̃_{p,mk} = φ_k^H · w_{p,m} ~ CN(0, 1) (the noise after projection is
  still CN(0,1) because ‖φ_k‖² = 1).

  Let's break this down into three terms:

  ┌──────────────────┬─────────────────────────────┬────────────────────────┐
  │       Term       │         Expression          │        Meaning         │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Desired          │ √(τ_cf · ρ_cf) · g_mk       │ The channel we want    │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Pilot            │ √(τ_cf · ρ_cf) · Σ_{k'≠k}   │ Interference from      │
  │ contamination    │ g_mk' · φ_k'^H φ_k          │ co-pilot users         │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Noise            │ w̃_{p,mk}                    │ Filtered noise         │
  └──────────────────┴─────────────────────────────┴────────────────────────┘

  When φ_k'^H φ_k = 0 (orthogonal pilots): the second term vanishes, and
  ŷ_{p,mk} is a clean observation of g_mk plus noise.

  When φ_k'^H φ_k ≠ 0 (shared pilots): the AP sees g_mk mixed with g_mk' — it
  cannot tell them apart. This is pilot contamination.

  2.5 MMSE Channel Estimation — Equation (4)

  Now the AP must estimate g_mk from the observation ŷ_{p,mk}. Since everything
  is Gaussian, the Minimum Mean Square Error (MMSE) estimator is optimal and has
   a simple linear form.

  MMSE estimation theory recap: For jointly Gaussian x and y with zero means:

  x̂_MMSE = (C_xy / C_yy) · y

  where C_xy = E{x·y*} (cross-covariance) and C_yy = E{|y|²} (auto-covariance).

  Applying to our problem:

  The unknown is x = g_mk ~ CN(0, β_mk), the observation is y = ŷ_{p,mk}.

  Step 1: Cross-covariance C_{g,y}

  Since g_mk is independent of g_mk' (k' ≠ k) and of w̃_{p,mk}:

  C_{g,y} = E{g_mk · ŷ_{p,mk}*} = √(τ_cf · ρ_cf) · E{|g_mk|²} = √(τ_cf · ρ_cf) ·
   β_mk

  Step 2: Auto-covariance C_{y,y}

  C_{y,y} = E{|ŷ_{p,mk}|²}

          = τ_cf · ρ_cf · E{|g_mk|²}  +  τ_cf · ρ_cf · Σ_{k'≠k} E{|g_mk'|²} ·
  |φ_k'^H φ_k|²  +  1

          = τ_cf · ρ_cf · β_mk  +  τ_cf · ρ_cf · Σ_{k'≠k} β_mk' · |φ_k'^H φ_k|²
   +  1

          = τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|²  +  1

  Step 3: The MMSE estimate

  ĝ_mk = c_mk · ŷ_{p,mk}
  ... (4)

  where the MMSE coefficient is:

                          √(τ_cf · ρ_cf) · β_mk
  c_mk = ─────────────────────────────────────────────────────
          τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|²  +  1

  2.6 Numerical Example — MMSE Estimation

  Let's work through a concrete example to make this tangible.

  Setup: M = 3 APs, K = 3 users, τ_cf = 2 (only 2 orthogonal pilots for 3
  users).

  Pilot assignment: Users 1 and 3 share pilot φ₁, User 2 uses pilot φ₂. So:
  - φ₁^H φ₃ = 1 (same pilot)
  - φ₁^H φ₂ = 0 (orthogonal)

  Large-scale fading at AP 1:
  - β₁₁ = 10⁻⁸ (user 1 is 100m away)
  - β₁₂ = 10⁻⁹ (user 2 is 300m away)
  - β₁₃ = 10⁻⁷ (user 3 is 30m away)

  Let τ_cf · ρ_cf = 10⁸ (training SNR parameter).

  Computing c₁₁ (MMSE coeff for AP 1, User 1):

                       √(10⁸) · 10⁻⁸
  c₁₁ = ──────────────────────────────────────────
         10⁸ · (β₁₁·|φ₁^Hφ₁|² + β₁₂·|φ₂^Hφ₁|² + β₁₃·|φ₃^Hφ₁|²) + 1

                       10⁴ · 10⁻⁸
       = ──────────────────────────────────────────
         10⁸ · (10⁻⁸·1 + 10⁻⁹·0 + 10⁻⁷·1) + 1

                  10⁻⁴
       = ────────────────────
         10⁸·10⁻⁸ + 10⁸·10⁻⁷ + 1

                  10⁻⁴
       = ──────────────────
           1 + 10 + 1

                10⁻⁴
       = ─────────── ≈ 8.33 × 10⁻⁶
             12

  Notice the pilot contamination effect: The denominator includes 10⁸ · β₁₃ = 10
   (from user 3, who shares the same pilot). This 10× inflates the denominator,
  reducing the estimation quality for user 1. User 3 is closer to AP 1 and
  contaminates user 1's estimate.

  If pilots were orthogonal (no contamination from user 3):

  c₁₁ (no contamination) = 10⁻⁴ / (1 + 1) = 5 × 10⁻⁵

  That's 6× larger, meaning a much better estimate without pilot contamination.

  2.7 Properties of the MMSE Estimate

  The MMSE estimation has a beautiful decomposition:

  g_mk = ĝ_mk + ε_mk      (true channel = estimate + error)

  where:
  - ĝ_mk ~ CN(0, γ_mk) is the estimate
  - ε_mk ~ CN(0, β_mk − γ_mk) is the estimation error
  - ĝ_mk and ε_mk are statistically independent (fundamental property of MMSE
  for Gaussians: uncorrelated Gaussian ⟹ independent)

  The estimate variance γ_mk (also written as E{|ĝ_mk|²}) is:

                      τ_cf · ρ_cf · β_mk²
  γ_mk = ──────────────────────────────────────────────            ... (8)
          τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|² + 1

  Note: γ_mk = √(τ_cf · ρ_cf) · β_mk · c_mk. This γ_mk appears everywhere in the
   rate expressions later.

  2.8 Remark 1 & 2 — Key Insights

  Remark 1 (Pilot contamination): If τ_cf ≥ K, we can make all pilots orthogonal
   → no pilot contamination → the estimate ĝ_mk is independent of g_mk' for k' ≠
   k. But typically τ_cf < K (limited coherence interval), so contamination is
  unavoidable.

  Remark 2 (Decentralized estimation): Each AP estimates channels independently.
   AP m uses only its own received signal y_{p,m}. No coordination, no CSI
  sharing. This is essential for scalability.

  ---
  CHUNK 3: Downlink Payload Data Transmission

  3.1 The High-Level Picture

  After estimating channels, the APs transmit data to all K users. Each AP knows
   its own channel estimates and treats them as if they were the true channels.
  It uses conjugate beamforming — multiply each user's data symbol by the
  conjugate of the channel estimate. This is the simplest possible precoding
  scheme, and it works remarkably well in the Massive MIMO regime.

  The magic: when you sum up the signals from all M APs at a user, the desired
  signal adds up coherently (in phase), while interference from other users adds
   up incoherently (random phases, partially cancels). As M grows, the desired
  signal grows as M while interference grows as √M — the ratio improves.

  3.2 Conjugate Beamforming — Equation (5)

  The transmitted signal from the m-th AP is:

                K
  x_m = √ρ_df · Σ  √η_mk · ĝ*_mk · q_k                          ... (5)
               k=1

  where:
  - ρ_df = normalized downlink SNR (= downlink power / noise power)
  - η_mk = power control coefficient (how much power AP m allocates to user k)
  - ĝ_mk* = complex conjugate of the channel estimate (the beamforming weight)
  - q_k = data symbol for user k, with E{|q_k|²} = 1

  Why the conjugate ĝ_mk?* Think of it physically:

  The channel g_mk has some phase rotation θ_mk. The signal arriving at user k
  from AP m gets multiplied by g_mk = |g_mk|·e^{jθ_mk}. If we pre-multiply by
  ĝ*_mk ≈ |g_mk|·e^{−jθ_mk}, the product g_mk · ĝ*_mk ≈ |g_mk|² is real and 
  positive. The signals from all M APs arrive at user k approximately in phase
  and add up constructively. This is the phase alignment principle.

  3.3 Per-AP Power Constraint — Equations (6)–(8)

  Unlike collocated Massive MIMO (one total power budget for all antennas),
  Cell-Free has a separate power constraint at each AP:

  E{|x_m|²} ≤ ρ_df     for all m = 1, ..., M                      ... (6)

  Substituting Eq. (5) and using the fact that q_k's are independent with unit
  power:

                  K
  E{|x_m|²} = ρ_df · Σ  η_mk · E{|ĝ_mk|²}
                 k=1
                  K
             = ρ_df · Σ  η_mk · γ_mk
                 k=1

  So the power constraint becomes:

  K
  Σ  η_mk · γ_mk ≤ 1     for all m = 1, ..., M                    ... (7)
  k=1

  where γ_mk is defined as:

  γ_mk ≜ E{|ĝ_mk|²} = τ_cf · ρ_cf · β_mk · c_mk                 ... (8)

  Physical meaning of Eq. (7): Each AP m has a total power budget of 1
  (normalized). The fraction η_mk · γ_mk is the average power AP m spends on
  serving user k. The sum over all users must not exceed the budget.

  3.4 Received Signal at User k — Equation (9)

  The k-th user receives a superposition of signals from all M APs:

               M
  r_{d,k} =   Σ   g_mk · x_m  +  w_{d,k}
              m=1

             M    K
        = √ρ_df · Σ    Σ  √η_mk' · g_mk · ĝ*_mk' · q_k'  +  w_{d,k}     ... (9)
            m=1  k'=1

  where w_{d,k} ~ CN(0, 1) is additive noise at user k.

  Splitting into desired signal + interference:

                    M                                M    K
  r_{d,k} = √ρ_df · Σ  √η_mk · g_mk · ĝ*_mk · q_k + √ρ_df · Σ    Σ   √η_mk' ·
  g_mk · ĝ*_mk' · q_k' + w_{d,k}
                   m=1                               m=1  k'≠k
                └───────────── DS_k ─────────────┘       └──────────────── MUI_k
   ─────────────────┘

  where DS_k = desired signal, MUI_k = multi-user interference.

  3.5 Channel Hardening — Why No Downlink Pilots Are Needed

  This is one of the most profound aspects of Massive MIMO. Let's understand it
  step by step.

  The effective channel gain that user k sees is:

                M
  a_k  ≜  Σ  √η_mk · g_mk · ĝ*_mk
              m=1

  This is a sum of M random terms. By the law of large numbers, as M → ∞:

  a_k  →  E{a_k} = Σ_{m=1}^{M} √η_mk · E{g_mk · ĝ*_mk} = Σ_{m=1}^{M} √η_mk ·
  γ_mk

  The random channel gain concentrates around a deterministic constant. The
  channel "hardens" — the randomness disappears.

  Why this matters for downlink: In a normal system (say, a single AP serving a
  user), the user must estimate the channel to decode data. Here, the effective
  channel is approximately a known constant — the user just uses its expected
  value. No downlink pilots needed. This saves precious training overhead.

  Figure 2 of the paper confirms this. It compares:
  - Rate assuming user knows only statistics (Eq. 24)
  - Rate assuming a genie gives user the exact channel (Eq. 26)

  The gap is tiny, proving channel hardening works.

  Numerical intuition: If M = 100, and each term g_mk · ĝ*_mk has mean γ_mk and
  some variance, the sum of 100 such terms has variance/mean² that shrinks as
  1/M_eff (where M_eff is the effective number of contributing APs). Even with
  M_eff ≈ 15–20 (due to nearby APs dominating), the hardening is sufficient.

  3.6 What Gets Sent Over the Backhaul

  Let's be precise about the information flow:

                  CPU
                 ╱    ╲
       data symbols    power control coefficients
       q₁, q₂, ..., qK    η_mk (change slowly)
                │               │
                ▼               ▼
              AP m computes: x_m = √ρ_df · Σ_k √η_mk · ĝ*_mk · q_k
                                            ↑
                                     local channel estimate
                                     (never leaves AP m)

  The CPU sends each AP the same data symbols q₁,...,q_K plus the power control
  coefficients η_mk. The AP does all beamforming locally. This is what keeps the
   backhaul requirements manageable.

  ---
  CHUNK 4: Uplink Payload Data Transmission

  4.1 The High-Level Picture

  In the uplink, roles reverse. All K users transmit their data simultaneously
  (same time, same frequency) to all M APs. Each AP receives a cocktail mixture
  of all users' signals. The AP applies matched filtering — multiplying by the
  conjugate of its channel estimate — to extract each user's signal. These
  locally-filtered signals are forwarded to the CPU, which combines them for
  final detection.

  Think of it as 40 people talking simultaneously in a room with 100
  microphones. Each microphone tries to isolate each speaker using what it knows
   about the acoustics (channel estimates). The central server then combines all
   100 microphones' outputs for each speaker to get a clean signal.

  4.2 Uplink Signal Model — Equation (10)

  The k-th user transmits √(η_k) · q_k, where η_k ∈ [0, 1] is its uplink power
  control coefficient and q_k (E{|q_k|²} = 1) is the data symbol. The received
  signal at AP m is:

                       K
  y_{u,m} = √ρ_uf ·  Σ  g_mk · √η_k · q_k  +  w_{u,m}              ... (10)
                     k=1

  where:
  - ρ_uf = normalized uplink SNR
  - w_{u,m} ~ CN(0, 1) = additive noise at AP m

  Key difference from downlink: In the uplink, there are only K power control
  coefficients η_k (one per user), not M×K as in the downlink. This makes uplink
   power control much simpler.

  4.3 Matched Filtering at Each AP

  To detect user k's symbol, AP m multiplies the received signal by the
  conjugate of its channel estimate:

  r̂_{m,k} = ĝ*_mk · y_{u,m}

  This is done locally at AP m using only its own channel estimate. The result
  r̂_{m,k} is a scalar — one number representing AP m's "vote" on what user k
  transmitted.

  4.4 Combining at the CPU — Equation (11)

  AP m sends r̂_{m,k} = ĝ*mk · y{u,m} to the CPU via the backhaul. The CPU
  combines all M APs' contributions:

                M
  r_{u,k} =   Σ   ĝ*_mk · y_{u,m}
              m=1

            K    M                              M
      = √ρ_uf · Σ   √η_k' · ( Σ  ĝ*_mk · g_mk') · q_k'  +  Σ  ĝ*_mk · w_{u,m}
    ... (11)
           k'=1         m=1                           m=1

  Decomposing into signal and interference:

                         M                       K           M
      M
  r_{u,k} = √ρ_uf · √η_k · Σ  ĝ*_mk · g_mk · q_k  +  √ρ_uf · Σ   √η_k' · Σ
  ĝ*_mk · g_mk' · q_k' + Σ  ĝ*_mk · w_{u,m}
                        m=1                          k'≠k        m=1
        m=1
             └────────── desired signal ──────────┘     └────────── inter-user
  interference ──────────┘   └── noise ──┘

  4.5 Why Matched Filtering Works — Favorable Propagation

  The key inner product is:

           M
  a_kk' = Σ  ĝ*_mk · g_mk'
          m=1

  For the desired user (k' = k):

           M                    M
  a_kk = Σ  ĝ*_mk · g_mk  =  Σ  (|ĝ_mk|² + ĝ*_mk · ε_mk)
         m=1                  m=1

  Using the decomposition g_mk = ĝ_mk + ε_mk (estimate + error), and since ĝ_mk
  and ε_mk are independent:

  E{a_kk} = Σ_{m=1}^{M} E{|ĝ_mk|²} = Σ_{m=1}^{M} γ_mk

  As M grows, by the law of large numbers: a_kk / M → (1/M) · Σ_m γ_mk
  (deterministic).

  For interfering users (k' ≠ k) with orthogonal pilots:

  E{a_kk'} = Σ_{m=1}^{M} E{ĝ*_mk · g_mk'} = 0     (since ĝ_mk and g_mk' are
  independent)

  And by the law of large numbers: a_kk' / M → 0. This is favorable propagation:
   the channels of different users become asymptotically orthogonal.

  For interfering users (k' ≠ k) sharing the same pilot as k:

  E{a_kk'} = Σ_{m=1}^{M} E{ĝ*_mk · g_mk'} ≠ 0     (because ĝ_mk contains g_mk'
  contamination)

  This non-zero term persists even as M → ∞. This is the pilot contamination 
  bottleneck — it creates a ceiling on performance.

  4.6 What Travels Over the Backhaul (Uplink)

             AP m
              │
              │  computes: r̂_{m,k} = ĝ*_mk · y_{u,m}  for each k = 1,...,K
              │  (K scalar values per AP)
              │
              ▼
             CPU
              │
              │  combines: r_{u,k} = Σ_{m=1}^{M} r̂_{m,k}
              │  then detects q_k from r_{u,k}

  Each AP sends K complex scalars to the CPU (one per user). Total backhaul
  load: M × K complex numbers per coherence interval. Crucially, the AP sends
  the filtered signal, not the raw received signal — this is much more
  efficient.

  4.7 Comparison: Downlink vs. Uplink Processing

  ┌──────────────────┬─────────────────────────┬───────────────────────────┐
  │      Aspect      │        Downlink         │          Uplink           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Processing at AP │ Beamforming: multiply   │ Matched filter: multiply  │
  │                  │ q_k by ĝ*_mk            │ y_{u,m} by ĝ*_mk          │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ What AP needs    │ Channel estimates +     │ Channel estimates +       │
  │                  │ data symbols            │ received signal           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Backhaul content │ CPU → AP: data symbols  │ AP → CPU: filtered        │
  │                  │ q_k                     │ signals ĝ*mk · y{u,m}     │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Power control    │ η_mk (M × K variables)  │ η_k (K variables)         │
  │ variables        │                         │                           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Power constraint │ Per-AP: Σ_k η_mk · γ_mk │ Per-user: 0 ≤ η_k ≤ 1     │
  │                  │  ≤ 1                    │                           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Channel          │ User uses E{channel}    │ CPU uses E{channel} for   │
  │ hardening        │ for decoding            │ decoding                  │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Combining        │ Happens naturally over  │ Done at CPU after         │
  │                  │ the air                 │ backhaul                  │
  └──────────────────┴─────────────────────────┴───────────────────────────┘

  4.8 Summary of the Complete System Flow

  Timeline within one coherence interval (τ_c = 200 samples):

    ◄──── τ_cf = 20 ────►◄──────── ~90 ────────►◄──────── ~90 ────────►
    ┌────────────────────┬────────────────────────┬────────────────────────┐
    │   UPLINK TRAINING  │   DOWNLINK DATA        │   UPLINK DATA          │
    │                    │                        │                        │
    │ Users → APs:       │ APs → Users:           │ Users → APs:           │
    │ Send pilots φ_k    │ Conjugate beamforming   │ Send data √η_k · q_k  │
    │                    │ x_m = √ρ · Σ √η_mk    │                        │
    │ APs estimate:      │      · ĝ*_mk · q_k    │ APs apply MF:          │
    │ ĝ_mk = c_mk·ŷ_mk │                        │ r̂_mk = ĝ*_mk · y_um  │
    │                    │ Users decode using      │                        │
    │                    │ E{effective channel}    │ CPU combines:          │
    │                    │ (no DL pilots needed)   │ r_uk = Σ_m r̂_mk      │
    └────────────────────┴────────────────────────┴────────────────────────┘

  ---
  This completes the deep dive into Section II. The foundation is now solid —
  the channel model, estimation, and beamforming/filtering are the building
  blocks for everything that follows (rate derivations in Section III, power
  control in Section IV). Shall we move to Section III next?

✻ Cooked for 13m 18s

❯ /export understanding_paper_sec2.txt 
  ⎿  Conversation exported to: understanding_paper_sec2.txt

❯ Yes, now move to the next part. Section 3. 

● Let me do thorough research on Section III first, then provide the deep dive.

● 2 Agent agents finished (ctrl+o to expand)
   ├─ Research achievable rate bounds · 66 tool uses · 82.8k tokens
   │  ⎿  Done
   └─ Research SINR derivation details · 48 tool uses · 76.1k tokens
      ⎿  Done

● Now let me give you the complete deep dive into Section III.

  ---
  SECTION III: Performance Analysis — Complete Deep Dive

  ---
  CHUNK 1: Large-M Analysis (Section III-A) — What Happens as M → ∞

  1.1 The High-Level Picture (Simple Terms)

  Imagine you have 100 APs and 40 users. Now imagine increasing the number of
  APs to 1,000... 10,000... infinity. What happens? Three beautiful things:

  1. Noise disappears — with more APs listening, the collective SNR goes to
  infinity.
  2. Non-coherent interference vanishes — signals from other users (who use
  different pilots) cancel out through the law of large numbers.
  3. Small-scale fading averages out — the random channel fluctuations become
  deterministic.

  The only thing that survives is pilot contamination — interference from users
  who share the exact same pilot sequence. This is the fundamental ceiling of
  Massive MIMO.

  1.2 The Mathematical Tool: Tchebyshev's Theorem

  The paper uses a specific form of the Weak Law of Large Numbers (called
  Tchebyshev's theorem in the paper):

  Theorem: Let X₁, X₂, ..., Xₙ be independent random variables (not necessarily
  identically distributed) with E{Xᵢ} = μᵢ and Var{Xᵢ} ≤ c < ∞ for all i. Then:

    1                  1
   ─── (X₁+X₂+...+Xₙ) − ─── (μ₁+μ₂+...+μₙ)  ──→  0   in probability
    n                    n                        n→∞

  Why this matters: In Cell-Free MIMO, sums like Σ_m g_mk · ĝ*_mk' involve M
  independent terms (one per AP). As M → ∞, these sums converge to their
  expected values. The randomness vanishes.

  Key subtlety: The Xᵢ's need NOT be identically distributed — perfect for
  Cell-Free where each AP has a different β_mk. The only requirement is bounded
  variance, which holds because |g_mk · ĝ*_mk'|² has bounded variance for any
  finite β_mk.

  1.3 Downlink Signal Decomposition for Large-M

  Recall from Section II that the received signal at user k is:

                      M                                    M    K
  r_{d,k} = √ρ_df ·  Σ  √η_mk · g_mk · ĝ*_mk · q_k  +  √ρ_df · Σ    Σ   √η_mk' ·
   g_mk · ĝ*_mk' · q_k'  +  w_{d,k}
                     m=1                                  m=1  k'≠k
                    └──────────── DS_k ────────────┘       └────────────────
  MUI_k ────────────────┘

  Now let's analyze the inner products as M → ∞.

  1.4 Expanding the Inner Product Using Eq. (4)

  The key quantity is Σ_m √η_mk · g_mk · ĝ*mk'. Substituting the MMSE estimate 
  ĝ_mk' = c_mk' · ŷ{p,mk'} and expanding:

   M                          M                    ⎡                K
                   ⎤
   Σ  √η_mk · g_mk · ĝ*_mk' = Σ  √η_mk · c_mk' · g_mk · ⎢ √(τ_cf·ρ_cf) · Σ
  g*_mk'' · φ_k''^H·φ_k'  +  w̃*_{p,mk'} ⎥
  m=1                        m=1                   ⎣               k''=1
                   ⎦

  Expanding the sum over k'':

           M
  = τ_cf·ρ_cf · Σ  √η_mk · c_mk' · |g_mk|² · φ_k^H·φ_k'          ← term with
  k''=k (desired user)
          m=1

           K     M
  + τ_cf·ρ_cf · Σ    Σ  √η_mk · c_mk' · g_mk · g*_mk'' · φ_k''^H·φ_k'    ← terms
   with k''≠k (other users)
          k''≠k m=1

      M
  +   Σ  √η_mk · c_mk' · g_mk · w̃*_{p,mk'}                        ← noise term
     m=1

  1.5 Applying Tchebyshev's Theorem (Eq. 14)

  Now apply the law of large numbers to each term as M → ∞:

  Term 1 (k'' = k): Each summand √η_mk · c_mk' · |g_mk|² is independent across m
   (different APs).

   1    M                                           1    M
  ───   Σ  √η_mk · c_mk' · |g_mk|²  ──→  ───   Σ  √η_mk · c_mk' · β_mk     in
  probability
   M   m=1                              M→∞    M   m=1

  because E{|g_mk|²} = β_mk.

  Term 2 (k'' ≠ k, k'' ≠ k'): Each summand involves g_mk · g*_mk'' where m is
  the same AP. Since h_mk and h_mk'' are independent CN(0,1):

  E{g_mk · g*_mk''} = √(β_mk · β_mk'') · E{h_mk · h*_mk''} = 0

  By Tchebyshev: (1/M) Σ_m √η_mk · c_mk' · g_mk · g*_mk'' → 0.

  Term 3 (noise): Similarly, g_mk and w̃_{p,mk'} are independent, so the average
  tends to zero.

  1.6 The Surviving Signal as M → ∞ (Eqs. 15–18)

  Putting it all together, as M → ∞:

  Desired signal converges:

   1                         1    M
  ─── DS_k  ──→  τ_cf·ρ_cf·ρ_df · ─── Σ  √η_mk · c_mk · β_mk · q_k       ...
  (15)
   M          M→∞                M  m=1

  Using the fact that γ_mk = τ_cf · ρ_cf · β_mk · c_mk, this simplifies to:

   1                   1    M
  ─── DS_k  ──→  ρ_df · ─── Σ  √η_mk · γ_mk · q_k
   M          M→∞      M  m=1

  Multi-user interference converges:

   1                    1    M                                  K
  ─── MUI_k  ──→  τ_cf·ρ_cf·ρ_df · ─── Σ  √η_mk · c_mk · β_mk' · |φ_k'^H φ_k|² ·
   q_k'      ... (16)
   M           M→∞                 M  m=1                                k'≠k

  The only interference that survives comes from users k' where φ_k'^H φ_k ≠ 0
  (i.e., users sharing the same pilot as user k). If all pilots are orthogonal:

   1
  ─── MUI_k  ──→  0        (all interference vanishes!)           ... (18)
   M          M→∞

  1.7 Physical Interpretation

     As M → ∞:

     ┌─────────────────────────────────────────────────────────────┐
     │  ✓ Noise → 0              (drowned out by M-fold gain)     │
     │  ✓ Small-scale fading → 0 (averaged over M APs)            │
     │  ✓ Non-coherent MUI → 0   (random phases cancel)           │
     │  ✗ Pilot contamination → REMAINS (same pilot = same phase) │
     └─────────────────────────────────────────────────────────────┘

  Why pilot contamination survives: When users k and k' share the same pilot,
  the channel estimate ĝ_mk contains information about g_mk' (not just g_mk).
  The beamformer ĝ*_mk therefore coherently combines g_mk' with the same phase
  alignment as g_mk. This coherent alignment persists no matter how large M is —
   it's not randomness that averages out, it's systematic bias in the estimate.

  1.8 Numerical Illustration

  Setup: M APs, 2 users sharing the same pilot. User 1 is desired, User 2 is the
   contaminator.

  ┌───────────────────────────┬────────────┬──────┬───────┬────────┐
  │         Quantity          │  Scaling   │ M=10 │ M=100 │ M=1000 │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Desired signal            │ DS_k       │      │ O(M)  │ ~10    │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Pilot contamination       │ MUI_k      │      │ O(M)  │ ~10    │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Non-coherent interference │ O(√M)      │ ~3.2 │ ~10   │ ~31.6  │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Noise                     │ O(1)       │ ~1   │ ~1    │ ~1     │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ SINR                      │ → constant │ ~3   │ ~8    │ ~9.5   │
  └───────────────────────────┴────────────┴──────┴───────┴────────┘

  The SINR saturates because both desired signal and pilot contamination grow at
   the same rate O(M). The ratio approaches a finite ceiling determined by
  β_mk/β_mk'.

  ---
  CHUNK 2: The Use-and-Then-Forget (UatF) Bounding Technique

  2.1 The High-Level Picture

  For finite M, we can't just let M → ∞ and ignore interference. We need an
  exact, closed-form rate expression valid for any M and K. The problem: the
  user doesn't know the instantaneous effective channel, only its statistics.
  How do we bound the capacity?

  The Use-and-Then-Forget technique (from Medard 2000, Hassibi & Hochwald 2003)
  works in three steps:
  1. Use the channel estimate to design the beamformer (conjugate beamforming)
  2. Forget the channel estimate at the decoder — treat the effective channel as
   its mean value
  3. Treat everything else as worst-case Gaussian noise → capacity lower bound

  2.2 Signal Decomposition (Eq. 19)

  The downlink received signal at user k (Eq. 9) is rewritten as:

                                             K
  r_{d,k} = DS_k · q_k  +  BU_k · q_k  +   Σ   UI_{kk'} · q_k'  +  w_{d,k}
   ... (19)
                                            k'≠k

  where the three key terms are defined as:

                M
  DS_k  ≜  √ρ_df · E{ Σ  √η_mk · g_mk · ĝ*_mk }                    ... (20)
               m=1

                M                        M
  BU_k  ≜  √ρ_df · [ Σ  √η_mk · g_mk · ĝ*_mk  −  E{ Σ  √η_mk · g_mk · ĝ*_mk } ]
     ... (21)
               m=1                      m=1

                  M
  UI_{kk'} ≜ √ρ_df · Σ  √η_mk' · g_mk · ĝ*_mk'                     ... (22)
                 m=1

  DS_k (Desired Signal strength) — a deterministic scalar (the mean of the
  effective channel gain). This is what the user knows.

  BU_k (Beamforming Uncertainty) — the zero-mean random deviation of the
  effective channel from its mean. The user does not know this.

  UI_{kk'} (User Interference) — interference caused by the k'-th user. The user
   does not know this either.

  2.3 Why the Decomposition Works — Uncorrelated Terms

  The beauty is that DS_k · q_k is uncorrelated with each of the remaining
  terms:

  DS_k · q_k is uncorrelated with BU_k · q_k:

  E{(DS_k · q_k) · (BU_k · q_k)*} = E{DS_k · BU_k} · E{|q_k|²}
                                    = DS_k · E{BU_k} · 1
                                    = DS_k · 0  =  0      ✓

  (because BU_k has zero mean by construction)

  DS_k · q_k is uncorrelated with UI_{kk'} · q_k':

  E{(DS_k · q_k) · (UI_{kk'} · q_k')*} = DS_k · E{UI_{kk'}} · E{q_k · q*_k'}
                                         = DS_k · E{UI_{kk'}} · 0  =  0    ✓

  (because q_k and q_k' are independent for k ≠ k')

  2.4 The Worst-Case Noise Argument

  Since the signal DS_k · q_k is uncorrelated with the "effective noise" (BU_k ·
   q_k + Σ UI_{kk'} · q_k' + w_{d,k}), we can apply the information-theoretic 
  worst-case noise theorem:

  Theorem (Medard, 2000): For a channel Y = aX + N where a is a known constant 
  and N is uncorrelated with X, the mutual information I(X; Y) is minimized when
   N is Gaussian (for a given variance of N).

  Why Gaussian is worst-case: Gaussian noise maximizes entropy h(N) for a given
  variance. Since I(X; Y) = h(Y) - h(Y|X) = h(Y) - h(N), maximizing h(N)
  minimizes I(X; Y).

  Therefore, by assuming the effective noise is Gaussian, we get a lower bound
  on capacity:

  R_{d,k} ≥ log₂(1 + SINR_k)

  This is a rigorously achievable rate — any practical coding scheme can achieve
   at least this rate.

  2.5 The SINR Expression (Eq. 23)

                            |DS_k|²
  SINR_{d,k} = ────────────────────────────────────────────         ... (23)
                                  K
                E{|BU_k|²}  +   Σ   E{|UI_{kk'}|²}  +  1
                               k'≠k

  Now the task is to compute each term in closed form. That's Theorem 1.

  2.6 Why This Bound is Tight

  The gap between this lower bound and the true capacity depends on channel 
  hardening:

  - If the effective channel a_k = Σ_m √η_mk · g_mk · ĝ*_mk concentrates tightly
   around E{a_k}, then BU_k is small → the denominator is dominated by UI +
  noise → the bound is tight.
  - Figure 2 of the paper confirms: the gap between the statistics-only rate
  (Eq. 24) and the genie-aided rate (Eq. 26) is negligible for M ≥ 50.

  ---
  CHUNK 3: Theorem 1 — Achievable Downlink Rate (Eq. 24)

  3.1 Statement of Theorem 1

  Theorem 1: The achievable downlink rate for the k-th user in Cell-Free Massive
   MIMO with conjugate beamforming, for any finite M and K, is:

                                              ⎛
                    ⎞
                                              ⎜              ρ_df · (Σ_m √η_mk ·
   γ_mk)²           ⎟
  R^cf_{d,k} = log₂ ⎜ 1 +
  ──────────────────────────────────────────────────────────── ⎟    ... (24)
                                              ⎜       K    ⎛  M
      ⎞²    K   M                        ⎟
                                              ⎜  ρ_df·Σ    ⎜  Σ
  √η_mk'·γ_mk·|φ^H_k'φ_k|⎟  + ρ_df·Σ   Σ  η_mk'·γ_mk'·β_mk + 1 ⎟
                                              ⎜      k'≠k  ⎝ m=1
      ⎠       k'=1 m=1                   ⎟
                                              ⎝
                    ⎠

  Let me write this more cleanly. Define:

                M
  Numerator = ρ_df · ( Σ  √η_mk · γ_mk )²
               m=1

                   K     M                                          K    M
  Denominator = ρ_df · Σ   ( Σ  √η_mk' · γ_mk · |φ^H_k' φ_k|² )²  +  ρ_df · Σ
   Σ  η_mk' · γ_mk' · β_mk  +  1
                  k'≠k  m=1                                        k'=1 m=1

  3.2 Computing Each Term — The Proof (Appendix A)

  Let me derive each component step by step.

  Computing DS_k (Eq. 59)

  Using the MMSE decomposition g_mk = ĝ_mk + ε_mk where ĝ_mk ⊥ ε_mk:

           M
  DS_k = √ρ_df · Σ  √η_mk · E{g_mk · ĝ*_mk}
          m=1

           M
       = √ρ_df · Σ  √η_mk · E{(ĝ_mk + ε_mk) · ĝ*_mk}
          m=1

           M
       = √ρ_df · Σ  √η_mk · [E{|ĝ_mk|²} + E{ε_mk}·E{ĝ*_mk}]
          m=1                  ↑               ↑
                              = γ_mk           = 0 (independent, zero mean)

                  M
  ∴  DS_k = √ρ_df · Σ  √η_mk · γ_mk                                ... (59)
                 m=1

                         M
  ∴  |DS_k|² = ρ_df · ( Σ  √η_mk · γ_mk )²     ← this is the NUMERATOR
                        m=1

  Physical meaning: Each AP m contributes √η_mk · γ_mk to the coherent gain. The
   contributions are summed and then squared — this is the coherent beamforming 
  gain. As M grows, this term scales as O(M²).

  Computing E{|BU_k|²} (Eq. 60)

  The beamforming uncertainty variance is:

                   M
  E{|BU_k|²} = ρ_df · Σ  η_mk · [E{|g_mk · ĝ*_mk|²} − |E{g_mk · ĝ*_mk}|²]
                  m=1

  (The cross terms between different APs vanish because channels at different
  APs are independent.)

  We need the fourth moment E{|g_mk|² · |ĝ_mk|²}. Using g_mk = ĝ_mk + ε_mk:

  E{|g_mk|² · |ĝ_mk|²} = E{|ĝ_mk + ε_mk|² · |ĝ_mk|²}

                         = E{|ĝ_mk|⁴} + E{|ε_mk|² · |ĝ_mk|²}

                         (cross terms vanish: E{ε_mk · |ĝ_mk|² · ĝ*_mk} =
  E{ε_mk} · E{|ĝ_mk|² · ĝ*_mk} = 0)

  Now using the Gaussian fourth moment: for z ~ CN(0, σ²):

  E{|z|⁴} = 2σ⁴

  This is because |z|² ~ Exp(1/σ²), so E{|z|⁴} = E{(|z|²)²} = 2(σ²)² (second
  moment of exponential).

  Applying this:

  E{|ĝ_mk|⁴} = 2γ²_mk                          (since ĝ_mk ~ CN(0, γ_mk))

  E{|ε_mk|² · |ĝ_mk|²} = E{|ε_mk|²} · E{|ĝ_mk|²}    (independence)
                         = (β_mk − γ_mk) · γ_mk

  Therefore:

  E{|g_mk|² · |ĝ_mk|²} = 2γ²_mk + (β_mk − γ_mk) · γ_mk
                         = 2γ²_mk + β_mk · γ_mk − γ²_mk
                         = γ²_mk + β_mk · γ_mk
                         = γ_mk · (γ_mk + β_mk)

  Subtracting the squared mean γ²_mk:

  E{|g_mk · ĝ*_mk|²} − |E{g_mk · ĝ*_mk}|² = γ_mk · (γ_mk + β_mk) − γ²_mk = γ_mk
  · β_mk

  Final result:

                   M
  E{|BU_k|²} = ρ_df · Σ  η_mk · γ_mk · β_mk                       ... (60)
                  m=1

  Physical meaning: This is the variance of the effective channel gain. Each AP
  m contributes η_mk · γ_mk · β_mk — it's large when the estimate γ_mk is good
  AND the channel β_mk is strong. This term scales as O(M).

  Computing E{|UI_{kk'}|²} (Eqs. 61–68)

  This is the most intricate part. The interference from user k' to user k is:

                M
  UI_{kk'} = √ρ_df · Σ  √η_mk' · g_mk · ĝ*_mk'
               m=1

  Substituting ĝ_mk' = c_mk' · ŷ_{p,mk'} and expanding, we get two types of
  terms:

  Non-coherent part (from channel estimation noise and independent fading):

             M
  = ρ_df ·   Σ  η_mk' · c²_mk' · β_mk                (scales as O(M))
            m=1

  Coherent pilot contamination part (only when φ^H_k' φ_k ≠ 0):

                      M                                  ²
  = ρ_df · |φ^H_k' φ_k|² · ( Σ  √η_mk' · c_mk' · β_mk · φ^H_k φ_k )      (scales
   as O(M²))
                     m=1

  Using the relationship γ_mk = τ_cf · ρ_cf · β_mk · c_mk, the full expression
  simplifies to:

                                 M                                        ²
      M
  E{|UI_{kk'}|²} = ρ_df · |φ^H_k' φ_k|² · ( Σ  √η_mk' · γ_mk ·
  (β_mk'/β_mk)·(c_mk'/c_mk) )  +  ρ_df · Σ  η_mk' · γ_mk' · β_mk
                                m=1
     m=1

  When users share the same pilot (|φ^H_k' φ_k|² = 1), the first term gives the
  coherent interference that scales as M². When pilots are orthogonal (|φ^H_k'
  φ_k|² = 0), only the second (non-coherent) term survives.

  3.3 Putting It All Together — The Complete SINR

  The denominator of the SINR in Eq. (24) combines all interference and noise:

                       K      ⎛ M                              ⎞²      K    M
  Denom = ρ_df ·  Σ    ⎜ Σ  √η_mk' · γ_mk · |φ^H_k' φ_k|  ⎟  +  ρ_df · Σ    Σ
  η_mk' · γ_mk' · β_mk  +  1
                 k'≠k  ⎝m=1                              ⎠       k'=1 m=1
                 └────────── pilot contamination (coherent) ────────┘    └── BU
  + non-coherent UI ──┘     └noise┘

  ┌──────────────────────────────┬───────────────────────────┬──────────────┐
  │       Denominator term       │          Origin           │ Scaling with │
  │                              │                           │       M      │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ (Σ_m √η_mk' · γ_mk · |φ^H_k' │ Pilot contamination       │ O(M²)        │
  │  φ_k|)²                      │                           │              │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ Σ_m η_mk' · γ_mk' · β_mk     │ BU + non-coherent         │ O(M)         │
  │                              │ interference              │              │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ 1                            │ Noise                     │ O(1)         │
  └──────────────────────────────┴───────────────────────────┴──────────────┘

  3.4 Numerical Example — Understanding the SINR

  Setup: M = 4 APs, K = 2 users, orthogonal pilots (|φ^H₁ φ₂|² = 0).

  ┌──────┬────────┬────────┬────────┬────────┐
  │ AP m │ β_{m1} │ β_{m2} │ γ_{m1} │ γ_{m2} │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 1    │ 0.5    │ 0.01   │ 0.4    │ 0.008  │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 2    │ 0.1    │ 0.3    │ 0.08   │ 0.24   │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 3    │ 0.2    │ 0.05   │ 0.16   │ 0.04   │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 4    │ 0.02   │ 0.4    │ 0.016  │ 0.32   │
  └──────┴────────┴────────┴────────┴────────┘

  Equal power: η_mk = 1/(K · max_k γ_mk) for each AP m (satisfying constraint
  Eq. 7). For simplicity, let η_mk = 1 for all m,k and ρ_df = 10.

  Numerator (desired signal for user 1):

  ρ_df · (Σ_m √η_m1 · γ_m1)² = 10 · (0.4 + 0.08 + 0.16 + 0.016)² = 10 · (0.656)²
   = 10 · 0.430 = 4.30

  Denominator — coherent term: Zero (orthogonal pilots, |φ^H₂ φ₁|² = 0).

  Denominator — BU + non-coherent UI:

  BU (k'=1):  10 · Σ_m η_m1 · γ_m1 · β_m1 = 10 · (0.4·0.5 + 0.08·0.1 + 0.16·0.2
  + 0.016·0.02)
            = 10 · (0.2 + 0.008 + 0.032 + 0.00032) = 10 · 0.240 = 2.40

  UI (k'=2): 10 · Σ_m η_m2 · γ_m2 · β_m1 = 10 · (0.008·0.5 + 0.24·0.1 + 0.04·0.2
   + 0.32·0.02)
            = 10 · (0.004 + 0.024 + 0.008 + 0.0064) = 10 · 0.042 = 0.42

  SINR₁ = 4.30 / (0 + 2.40 + 0.42 + 1) = 4.30 / 3.82 = 1.126

  Rate₁ = log₂(1 + 1.126) = log₂(2.126) = 1.09 bits/s/Hz

  Now imagine M = 400 APs with similar statistics. The numerator scales as
  (400/4)² · 4.30 ≈ 43,000, the BU+UI scales as (400/4) · 2.82 ≈ 282, noise
  stays at 1. SINR ≈ 43,000/283 ≈ 152 → Rate ≈ 7.25 bits/s/Hz. The M²/M = M
  scaling gives huge gains!

  ---
  CHUNK 4: Theorem 2 (Uplink Rate), Remarks, and Figure 2

  4.1 Theorem 2 — Achievable Uplink Rate (Eq. 27)

  Theorem 2: The achievable uplink rate for the k-th user in Cell-Free Massive
  MIMO with matched filtering, for any M and K, is:

                                          ⎛
                   ⎞
                                          ⎜          ρ_uf · η_k · (Σ_m γ_mk)²
                   ⎟
  R^cf_{u,k} = log₂ ⎜ 1 +
  ──────────────────────────────────────────────────────── ⎟     ... (27)
                                          ⎜       K    ⎛ M
  ⎞²    K   M                       M      ⎟
                                          ⎜  ρ_uf·Σ  η_k'·⎜Σ  γ_mk·|φ^H_k'φ_k|⎟
   + ρ_uf·Σ  η_k'·Σ  γ_mk·β_mk' + Σ  γ_mk ⎟
                                          ⎜      k'≠k ⎝m=1                   ⎠
      k'=1  m=1              m=1     ⎟
                                          ⎝
                   ⎠

  4.2 Term-by-Term Comparison: Downlink vs. Uplink SINR

  ┌──────────────┬─────────────────────────────┬────────────────────────────┐
  │              │   Downlink SINR (Eq. 24)    │    Uplink SINR (Eq. 27)    │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Numerator    │ ρ_df · (Σ_m √η_mk · γ_mk)²  │ ρ_uf · η_k · (Σ_m γ_mk)²   │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Power ctrl   │ η_mk (M×K values)           │ η_k (K values)             │
  │ vars         │                             │                            │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Pilot        │ Σ_{k'≠k} (Σ_m √η_mk' · γ_mk │ Σ_{k'≠k} η_k' · (Σ_m γ_mk  │
  │ contam.      │  · |φ^H_k'φ_k|)²            │ · |φ^H_k'φ_k|)²            │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Non-coh.     │ Σ_{k'} Σ_m η_mk' · γ_mk' ·  │ Σ_{k'} η_k' · Σ_m γ_mk ·   │
  │ interf.      │ β_mk                        │ β_mk'                      │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Noise term   │ 1                           │ Σ_m γ_mk                   │
  └──────────────┴─────────────────────────────┴────────────────────────────┘

  Key differences:

  1. Numerator structure: In the downlink, each AP m has its own √η_mk inside
  the sum, giving M×K degrees of freedom for power allocation. In the uplink,
  there is one η_k per user — all APs combine with the same power weight, giving
   only K degrees of freedom.
  2. Noise term: In the downlink, noise is simply 1 (normalized). In the uplink,
   noise is amplified by the matched filter: the combining vector ĝ*_mk
  amplifies noise by |ĝ_mk|², and Σ_m E{|ĝ_mk|²} = Σ_m γ_mk. This noise
  enhancement is the price of matched filtering.
  3. The uplink is structurally simpler — it's a quasi-linear optimization
  problem (solved by bisection + LP), while the downlink is quasi-concave
  (bisection + SOCP).

  4.3 Remark 3 — Reduction to Collocated Massive MIMO

  When all APs are collocated: β_mk = β_k for all m, γ_mk = γ_k, and we set η_mk
   = η_k / (M · γ_k) (equal power split). With orthogonal pilots (|φ^H_k' φ_k|²
  = 0 for k' ≠ k):

  Downlink reduces to:

                                M · ρ_df · η_k · γ_k
  R^cf_{d,k}  →  log₂( 1 + ─────────────────────────── )              ... (25)
                              ρ_df · Σ_{k'} η_k' + 1

  This is exactly the standard collocated Massive MIMO rate from Ngo et al. 2013
   and the textbook by Marzetta et al. This confirms Cell-Free Massive MIMO is a
   strict generalization of collocated Massive MIMO.

  4.4 Remark 4 & Figure 2 — Validating Channel Hardening

  Remark 4 compares two quantities:

  1. Eq. (24) — achievable rate when user knows only channel statistics
  (E{effective channel})
  2. Eq. (26) — genie-aided rate when user knows the exact instantaneous
  effective channel

  Equation (26) is:

  R̃^cf_{d,k} = E{ log₂( 1 + ρ_df · |Σ_m √η_mk · g_mk · ĝ*_mk|² / (ρ_df ·
  Σ_{k'≠k} |Σ_m √η_mk' · g_mk · ĝ*_mk'|² + 1) ) }

  Figure 2 plots both for various M with K = 10 and K = 20:

    Rate
    (bits/s/Hz)
     5 ┤
       │                                    ─── genie-aided (Eq. 26)
     4 ┤                              ·····  ─── statistics only (Eq. 24)
       │                       ···· ─────────
     3 ┤              ···─────────  K=10
       │      ···─────
     2 ┤ ···──────────────────────────────── K=20
       │──────
     1 ┤
       │
     0 ┼───┬───┬───┬───┬───┬───┬───┬───┬──→ M
       20  40  60  80  100 120 140 160 200

  The gap between the two curves is tiny — confirming that:
  - Channel hardening works in Cell-Free MIMO (the effective channel
  concentrates around its mean)
  - Downlink pilots are unnecessary (using only statistics costs almost nothing)
  - Eq. (24) is a tight, practical bound that can be used for system design

  4.5 Remark 5 — Uplink Reduces to Collocated (Sanity Check)

  Similarly, with collocated APs and orthogonal pilots, Eq. (27) reduces to:

                              M · ρ_uf · η_k · γ_k
  R^cf_{u,k}  →  log₂( 1 + ─────────────────────────── )              ... (28)
                             ρ_uf · Σ_{k'} η_k' + 1

  which matches the known collocated Massive MIMO uplink rate from Ngo & Larsson
   2013.

  4.6 Summary: The Complete Rate Analysis Framework

    ┌──────────────────────────────────────────────────────────────┐
    │                    SECTION III SUMMARY                       │
    ├──────────────────────────────────────────────────────────────┤
    │                                                              │
    │  Large-M Analysis (III-A):                                   │
    │  • As M→∞: noise, non-coherent interference, fading → 0     │
    │  • Only pilot contamination survives                         │
    │  • Tool: Tchebyshev's theorem (WLLN for non-i.i.d.)         │
    │                                                              │
    │  Finite-M Analysis (III-B):                                  │
    │  • Use-and-Then-Forget bounding technique                    │
    │  • Signal = DS·q + BU·q + Σ UI·q' + noise                   │
    │  • Worst-case Gaussian noise → capacity lower bound          │
    │                                                              │
    │  Theorem 1 (Downlink):                                       │
    │  • Numerator: ρ_df · (Σ_m √η_mk · γ_mk)²   [coherent gain] │
    │  • Denom: pilot contam. (O(M²)) + BU+UI (O(M)) + noise (1)  │
    │  • Power control: M×K variables η_mk                        │
    │                                                              │
    │  Theorem 2 (Uplink):                                         │
    │  • Numerator: ρ_uf · η_k · (Σ_m γ_mk)²     [coherent gain]  │
    │  • Denom: pilot contam. + interference + noise enhancement   │
    │  • Power control: K variables η_k (simpler)                  │
    │                                                              │
    │  Key Insight: γ_mk is the fundamental building block —       │
    │  it encodes channel quality, pilot contamination, and        │
    │  training investment in one parameter.                       │
    └──────────────────────────────────────────────────────────────┘

  The closed-form SINR depends only on large-scale fading coefficients {β_mk}
  and power control variables {η_mk} — not on instantaneous channel
  realizations. This is what makes max-min power control (Section IV) tractable
  and globally optimal.

  ---
  Ready to move to Section IV (Pilot Assignment and Power Control)?

✻ Cogitated for 17m 57s

❯ /export understanding_paper_sec3_v2.txt 
  ⎿  Conversation exported to: understanding_paper_sec3_v2.txt

❯ Now, move to section IV. 

● Let me do thorough research on Section IV first.

● 2 Agent agents finished (ctrl+o to expand)
   ├─ Research pilot assignment algorithms · 54 tool uses · 48.1k tokens
   │  ⎿  Done
   └─ Research max-min power control · 42 tool uses · 50.1k tokens
      ⎿  Done

● Now here's the complete deep dive into Section IV.

  ---
  SECTION IV: Pilot Assignment and Power Control — Complete Deep Dive

  ---
  CHUNK 1: Why Pilot Assignment & Power Control Matter + Overview

  1.1 The High-Level Picture (Simple Terms)

  You have 100 APs and 40 users. Two critical questions arise:

  Question 1 (Pilot Assignment): You only have, say, 20 orthogonal pilot
  sequences for 40 users. Each pilot must be shared by 2 users. Which users 
  should share a pilot? If two users who are physically close share the same
  pilot, the APs can't tell their channels apart → severe pilot contamination →
  terrible performance for both. You want users who share a pilot to be as
  geographically separated as possible.

  Question 2 (Power Control): Some users are close to many APs (strong
  channels), others are far from most APs (weak channels). If all APs blast at
  full power, the strong users get great service but the weak users drown in
  interference. How should you allocate power? Answer: max-min fairness —
  intentionally reduce power for strong users and redirect it to weak users, so
  that the worst user's rate is maximized. Everyone gets the same rate.

  1.2 A Critical Insight from the Paper

  "A pilot assignment algorithm helps to mitigate the effects of pilot 
  contamination, but power control is far more important in that regard."

  The paper quantifies this:
  - Max-min power control improves the 95%-likely throughput by a factor of
  ~2.5× (downlink) and ~2.3× (uplink) compared to no power control
  - Greedy pilot assignment improves it by only ~20% over random assignment

  Power control is the dominant resource management tool.

  1.3 Why They Can Be Done Independently

  Pilot assignment and power control operate on different variables and can be
  optimized sequentially:

  Step 1: Pilot Assignment → determines which users share pilots
              (affects the sets P_k and the γ_mk values)

  Step 2: Power Control → given the pilot assignment, optimizes power
  coefficients
              (optimizes η_mk or η_k to maximize the worst user's rate)

  They are independent because:
  - Pilot sequences are not power controlled — all users transmit pilots at the
  same power ρ_cf
  - The pilot assignment determines the channel estimation quality γ_mk
  - Power control then takes γ_mk as fixed input and optimizes over η

  Both operate on the large-scale fading timescale (changes every ~40 coherence
  intervals), so they are recomputed only a few times per second even at high
  user mobility.

  1.4 The Optimization Landscape

  ┌────────────────────────────────────────────────────────────────────────┐
  │                    RESOURCE MANAGEMENT                                │
  ├──────────────────────────┬─────────────────────────────────────────────┤
  │   PILOT ASSIGNMENT       │   POWER CONTROL                            │
  │   (Section IV-A)         │   (Section IV-B)                           │
  ├──────────────────────────┼─────────────────────────────────────────────┤
  │ Variables: φ₁,...,φ_K    │ DL: η_mk (M×K variables)                   │
  │   (discrete, from set S) │ UL: η_k  (K variables)                     │
  ├──────────────────────────┼─────────────────────────────────────────────┤
  │ Objective: minimize      │ Objective: maximize minimum user rate       │
  │   pilot contamination    │   (max-min fairness)                       │
  ├──────────────────────────┼─────────────────────────────────────────────┤
  │ Type: NP-hard            │ DL: quasi-concave → bisection + SOCP       │
  │   combinatorial          │ UL: quasi-linear  → bisection + LP         │
  ├──────────────────────────┼─────────────────────────────────────────────┤
  │ Solution: greedy         │ Solution: globally optimal                  │
  │   heuristic (Algorithm 1)│   (Algorithm 2 + bisection)                │
  ├──────────────────────────┼─────────────────────────────────────────────┤
  │ Impact: ~20%             │ Impact: ~250% improvement                   │
  │   improvement            │   at 95%-likely throughput                  │
  └──────────────────────────┴─────────────────────────────────────────────┘

  ---
  CHUNK 2: Greedy Pilot Assignment (Algorithm 1)

  2.1 The Problem Setup

  We have τ_cf orthogonal pilot sequences forming a set S = {s₁, s₂, ..., 
  s_{τ_cf}}. Each user k is assigned one pilot φ_k ∈ S. Since τ_cf < K, multiple
   users share each pilot. The question: which assignment minimizes the overall
  pilot contamination?

  The optimal pilot assignment is NP-hard. Pinto et al. (2023) proved this
  rigorously — it's equivalent to a graph partitioning problem (MAX P-CUT),
  which is one of the classic NP-hard problems. The search space has τ_cf^K
  possible assignments (e.g., 20⁴⁰ ≈ 10⁵² for our parameters — utterly
  intractable).

  2.2 The Pilot Contamination Metric — Equation (29)

  For user k using pilot φ_k, the pilot contamination at AP m from all co-pilot
  users is:

                      K
  E{| Σ  g_mk' · φ^H_k' · φ_k |²} = Σ   β_mk' · |φ^H_k' · φ_k|²       ... (29)
     k'≠k                            k'≠k

  Physical meaning: This is the total interference power that contaminates user
  k's channel estimate at AP m. It sums the large-scale fading β_mk' of every
  co-pilot user k' (weighted by pilot correlation |φ^H_k' · φ_k|²).

  Why sum over all APs? In Cell-Free MIMO, every AP estimates every user's
  channel. So the total system-wide contamination for user k is:

                M     K
  V_k = Σ    Σ   β_mk' · |φ^H_k' · φ_k|²                           ... (30
  summed)
       m=1  k'≠k

  When using orthogonal pilots from set S (where |φ^H_k' · φ_k|² is either 0 or
  1):

           M
  V_k = Σ    Σ     β_mk'        (sum over APs and co-pilot users only)
       m=1  k'∈P_k
            k'≠k

  2.3 Greedy Pilot Assignment — Algorithm 1 (Step by Step)

  ┌─────────────────────────────────────────────────────────────────┐
  │               ALGORITHM 1: Greedy Pilot Assignment              │
  ├─────────────────────────────────────────────────────────────────┤
  │                                                                 │
  │  INPUT:  K users, M APs, τ_cf pilots, {β_mk}, max iterations N │
  │  OUTPUT: Pilot assignment {φ₁, φ₂, ..., φ_K}                   │
  │                                                                 │
  │  STEP 1 (Initialization):                                       │
  │    Randomly assign each user a pilot from S = {s₁,...,s_{τ_cf}} │
  │    Set iteration counter n = 1                                  │
  │                                                                 │
  │  STEP 2 (Find worst user):                                      │
  │    Compute R^cf_{d,k} for all k using Eq. (24)                  │
  │    Find: k* = arg min_k  R^cf_{d,k}          ... (31)           │
  │    (the user with the lowest downlink rate)                     │
  │                                                                 │
  │  STEP 3 (Reassign pilot for worst user):                        │
  │    For each candidate pilot s_t ∈ S:                            │
  │      Compute the contamination if user k* used pilot s_t:       │
  │             M     K                                             │
  │      C_t = Σ     Σ    β_mk' · |φ^H_k' · s_t|²                 │
  │            m=1  k'≠k*                                           │
  │    Assign: φ_{k*} = arg min_{s_t ∈ S}  C_t          ... (30)    │
  │                                                                 │
  │  STEP 4 (Iterate):                                              │
  │    Set n = n + 1                                                │
  │    If n > N: STOP                                               │
  │    Otherwise: go to Step 2                                      │
  │                                                                 │
  └─────────────────────────────────────────────────────────────────┘

  2.4 Detailed Walkthrough with Numerical Example

  Setup: M = 4 APs, K = 6 users, τ_cf = 3 pilots (so each pilot shared by 2
  users).

  Large-scale fading matrix β_mk (rows = APs, columns = users):

          U₁    U₂    U₃    U₄    U₅    U₆
  AP₁  [ 0.50  0.01  0.30  0.02  0.40  0.05 ]
  AP₂  [ 0.02  0.40  0.05  0.35  0.01  0.30 ]
  AP₃  [ 0.10  0.20  0.01  0.15  0.25  0.03 ]
  AP₄  [ 0.03  0.05  0.20  0.10  0.02  0.45 ]

  Step 1: Random initial assignment: φ₁=s₁, φ₂=s₁, φ₃=s₂, φ₄=s₂, φ₅=s₃, φ₆=s₃

  So the groups are: {U₁,U₂}, {U₃,U₄}, {U₅,U₆}

  Step 2: Compute contamination for each user.

  User 1's contamination (from co-pilot User 2):
  V₁ = Σ_m β_{m,2} = 0.01 + 0.40 + 0.20 + 0.05 = 0.66

  User 2's contamination (from co-pilot User 1):
  V₂ = Σ_m β_{m,1} = 0.50 + 0.02 + 0.10 + 0.03 = 0.65

  User 3's contamination (from co-pilot User 4):
  V₃ = Σ_m β_{m,4} = 0.02 + 0.35 + 0.15 + 0.10 = 0.62

  User 4's contamination (from co-pilot User 3):
  V₄ = Σ_m β_{m,3} = 0.30 + 0.05 + 0.01 + 0.20 = 0.56

  User 5's contamination (from co-pilot User 6):
  V₅ = Σ_m β_{m,6} = 0.05 + 0.30 + 0.03 + 0.45 = 0.83    ← WORST

  User 6's contamination (from co-pilot User 5):
  V₆ = Σ_m β_{m,5} = 0.40 + 0.01 + 0.25 + 0.02 = 0.68

  Step 2 result: User 5 has the worst contamination (V₅ = 0.83).

  Step 3: Try reassigning User 5 to each pilot:

  - If φ₅ = s₁ (join {U₁,U₂}): New V₅ = Σ_m (β_{m,1} + β_{m,2}) = 0.65 + 0.66 =
  1.31
  - If φ₅ = s₂ (join {U₃,U₄}): New V₅ = Σ_m (β_{m,3} + β_{m,4}) = 0.56 + 0.62 =
  1.18
  - If φ₅ = s₃ (stay with {U₆}): V₅ = 0.83 (current)

  Wait — User 5 is currently with User 6. Let me reconsider. The contamination
  of User 5 under each candidate pilot considers all OTHER users already
  assigned to that pilot:

  - s₁ (currently {U₁,U₂}): V₅ = Σ_m (β_{m,1} + β_{m,2}) = 1.31
  - s₂ (currently {U₃,U₄}): V₅ = Σ_m (β_{m,3} + β_{m,4}) = 1.18
  - s₃ (currently {U₆} after removing U₅): V₅ = Σ_m β_{m,6} = 0.83

  The minimum is s₃ (stay). User 5 doesn't move. But now we should look more
  carefully at the rate (not just contamination). With rate computation via Eq.
  (24), the worst user might actually be different from the one with highest
  V_k. The algorithm uses rate as the criterion in Step 2 but contamination in
  Step 3.

  In practice after several iterations, the algorithm converges to an assignment
   where geographically close users use different pilots.

  2.5 Remark 6 — Practical Implementation

  Key points about the greedy algorithm:
  - Runs at the CPU (which has access to all {β_mk} via backhaul)
  - Recomputed on the large-scale fading timescale (a few times per second)
  - To inform users of their assigned pilot, the CPU sends only an index
  (log₂(τ_cf) bits) — extremely low overhead
  - The pilot set S is predetermined and known to all users
  - Complexity: O(N · K · τ_cf · M) per full run, where N is the number of
  iterations

  ---
  CHUNK 3: Downlink Max-Min Power Control (Algorithm 2)

  3.1 The Optimization Problem — Equation (32)

  Given the pilot assignment (fixed), find the downlink power control
  coefficients η_mk that maximize the minimum user rate:

  max     min    R^cf_{d,k}
  {η_mk}  k=1,...,K

  subject to:
     K
     Σ  η_mk · γ_mk ≤ 1     for all m = 1,...,M     (per-AP power constraint)
    k=1

    η_mk ≥ 0                  for all m, k

  Note: This has M × K optimization variables (e.g., 100 × 40 = 4,000
  variables). This is much more complex than the uplink (only K variables).

  3.2 Variable Substitution — Equation (33)

  Define ν_mk ≜ √η_mk (so η_mk = ν²_mk). Then the SINR from Eq. (24) becomes:

                          ⎛  M              ⎞²
                     ρ_df · ⎜ Σ  ν_mk · γ_mk ⎟
                          ⎝ m=1             ⎠
  SINR_{d,k} = ────────────────────────────────────────────────────────
                   K     ⎛ M                       ⎞²     K    M
              ρ_df · Σ   ⎜ Σ  ν_mk'·γ_mk·|φ^H_k'φ_k| ⎟  + ρ_df · Σ    Σ
  ν²_mk'·γ_mk'·β_mk + 1
                  k'≠k   ⎝m=1                      ⎠    k'=1 m=1

  And the power constraint becomes:

   K
   Σ  ν²_mk · γ_mk ≤ 1     for all m                                ... (7')
  k=1

  3.3 Introducing Slack Variables — Equation (34)

  To make the optimization more tractable, the paper introduces slack variables
  σ_m and κ_{kk'}:

  max       min     (Σ_m ν_mk · γ_mk)²
  {ν,κ,σ}   k=1,...,K   ──────────────────────────────────────────────
                         K                       K    M
                     Σ  κ²_{kk'} · |φ^H_k'φ_k|²  + Σ    Σ  ν²_mk'·γ_mk'·β_mk +
  1/ρ_df
                    k'≠k                         k'=1 m=1

  subject to:
     K
     Σ  ν²_mk · γ_mk ≤ σ²_m     for all m         (per-AP power)
    k=1

     M
     Σ  ν_mk' · γ_mk · (β_mk'/β_mk)·... ≤ κ_{kk'}     for all k'≠k     (pilot
  contamination bound)
    m=1

    0 ≤ σ_m ≤ 1                  for all m
    ν_mk ≥ 0                     for all m, k

  The key insight: σ_m and κ_{kk'} hold with equality at the optimum (because
  tightening them can only improve the objective). This equivalence is proven in
   Appendix B.

  3.4 Why the Problem is Quasi-Concave — Proposition 1

  Definition (Quasi-concave): A function f is quasi-concave if for every value
  t, the superlevel set {x : f(x) ≥ t} is convex.

  Why our objective is quasi-concave:

  The objective function f(ν, κ, σ) = min_k SINR_k has the structure:

                    (linear function of ν)²
  SINR_k = ────────────────────────────────────────
            (quadratic function of ν, κ) + constant

  - Numerator: (Σ_m ν_mk · γ_mk)² — the square of a linear function → concave in
   ν (actually it's the square of a non-negative linear function, which is
  convex — but the ratio structure still works)
  - Denominator: quadratic + constant → convex in (ν, κ)

  For the superlevel set {ν : SINR_k ≥ t}:

  (Σ_m ν_mk · γ_mk)² ≥ t · [denominator]

  This can be rewritten as a second-order cone constraint (which defines a
  convex set). The intersection of convex sets (over all k) is convex. Therefore
   the minimum SINR is quasi-concave.

  3.5 The Bisection Algorithm — Algorithm 2

  Since the problem is quasi-concave, it can be solved by bisection: binary
  search on the objective value t, checking feasibility at each step.

  ┌─────────────────────────────────────────────────────────────────────┐
  │            ALGORITHM 2: Bisection for Downlink Power Control        │
  ├─────────────────────────────────────────────────────────────────────┤
  │                                                                     │
  │  STEP 1 (Initialization):                                           │
  │    t_min = SINR with equal power allocation (guaranteed feasible)   │
  │    t_max = generous upper bound (e.g., single-user no-interference) │
  │    Choose tolerance ε > 0                                           │
  │                                                                     │
  │  STEP 2 (Bisect):                                                   │
  │    Set t = (t_min + t_max) / 2                                      │
  │                                                                     │
  │    Solve the SOCP feasibility problem (Eq. 35):                     │
  │    ┌───────────────────────────────────────────────────────────┐     │
  │    │  Find {ν_mk, κ_{kk'}, σ_m} such that:                   │     │
  │    │                                                           │     │
  │    │  ‖v_k‖ ≤ (1/√t) · Σ_m ν_mk · γ_mk    for all k        │     │
  │    │                                                           │     │
  │    │  where v_k collects all interference + noise terms        │     │
  │    │  into a vector whose norm must be bounded                 │     │
  │    │                                                           │     │
  │    │  Σ_k ν²_mk · γ_mk ≤ σ²_m              for all m         │     │
  │    │  Σ_m ν_mk' · γ_mk · ... ≤ κ_{kk'}     for all k'≠k     │     │
  │    │  0 ≤ σ_m ≤ 1,  ν_mk ≥ 0                                │     │
  │    └───────────────────────────────────────────────────────────┘     │
  │                                                                     │
  │  STEP 3 (Update bounds):                                            │
  │    If FEASIBLE:  t_min = t   (we can do at least this well)         │
  │    If INFEASIBLE: t_max = t  (this target is too ambitious)         │
  │                                                                     │
  │  STEP 4 (Check convergence):                                        │
  │    If t_max - t_min < ε: STOP, return last feasible solution        │
  │    Otherwise: go to Step 2                                          │
  │                                                                     │
  │  OUTPUT: Optimal η*_mk = ν*²_mk, max-min rate = log₂(1 + t_min)   │
  │                                                                     │
  │  ITERATIONS: ⌈log₂((t_max − t_min)/ε)⌉ ≈ 15-20                     │
  │  Each iteration: solve one SOCP (polynomial time)                   │
  │  RESULT: GLOBALLY OPTIMAL                                           │
  └─────────────────────────────────────────────────────────────────────┘

  3.6 Understanding the SOCP Feasibility Problem — Equation (35)

  For a fixed target SINR t, the constraint SINR_k ≥ t becomes:

  (Σ_m ν_mk · γ_mk)² ≥ t · [Σ_{k'≠k} κ²_{kk'} · |φ^H_k'φ_k|² + Σ_{k'} Σ_m
  ν²_mk'·γ_mk'·β_mk + 1/ρ_df]

  Taking square roots and rearranging into second-order cone form:

                      ⎡  √t · κ_{k,1} · |φ^H₁ φ_k|    ⎤
                      ⎢  √t · κ_{k,2} · |φ^H₂ φ_k|    ⎥
                      ⎢         ⋮                        ⎥
  ‖ v_k ‖₂  ≤  1   ⎢  √t · ν_{1,k'}·√(γ_{1,k'}β_{1,k})⎥         M
            ─── ·   ⎢         ⋮                        ⎥  ≤  Σ  ν_mk · γ_mk
            √t      ⎢  √(t/ρ_df)                       ⎥    m=1
                      ⎣                                  ⎦

  This is a standard second-order cone constraint: ‖Ax + b‖₂ ≤ cᵀx + d, which is
   convex. The SOCP feasibility problem is simply: do there exist variables (ν,
  κ, σ) satisfying all these cone constraints simultaneously?

  What is an SOCP? A Second-Order Cone Program is a convex optimization problem
  where constraints take the form ‖Ax + b‖₂ ≤ cᵀx + d (a "cone" in variable
  space). SOCPs can be solved in polynomial time by interior-point methods, and
  are supported by solvers like CVX/SDPT3/SeDuMi/MOSEK.

  3.7 Why the Solution is Globally Optimal

  This is a remarkable result. Many power control problems are non-convex and
  only admit local optima. Here, global optimality is guaranteed because:

  1. The problem is quasi-concave → bisection converges to the true optimum
  2. Each feasibility subproblem is a convex SOCP → solved exactly by
  interior-point methods
  3. The bisection converges to within ε of the true optimum in O(log(1/ε))
  iterations

  No heuristics, no local optima, no approximations — the algorithm finds the
  exactly optimal power allocation.

  3.8 Numerical Illustration of Bisection

  Setup: Suppose the SINR with equal power is 2.0 and a rough upper bound is
  20.0.

  Iter  t_min   t_max    t      Feasible?   Action
  ──────────────────────────────────────────────────
    1   2.0     20.0    11.0      No        t_max = 11.0
    2   2.0     11.0     6.5      No        t_max = 6.5
    3   2.0      6.5     4.25     Yes       t_min = 4.25
    4   4.25     6.5     5.375    Yes       t_min = 5.375
    5   5.375    6.5     5.9375   No        t_max = 5.9375
    6   5.375    5.9375  5.656    Yes       t_min = 5.656
    7   5.656    5.9375  5.797    No        t_max = 5.797
    8   5.656    5.797   5.727    Yes       t_min = 5.727
    ...
    14  5.74     5.75    5.745    Yes       t_min = 5.745  ← converged!

  After 14 iterations: optimal max-min SINR ≈ 5.745, giving rate = log₂(1 +
  5.745) ≈ 2.75 bits/s/Hz.

  ---
  CHUNK 4: Uplink Max-Min Power Control

  4.1 The Optimization Problem — Equations (36)–(37)

  The uplink max-min problem is structurally simpler:

  max      min     R^cf_{u,k}
  {η_k}   k=1,...,K

  subject to:  0 ≤ η_k ≤ 1     for all k = 1,...,K                    ... (36)

  Only K variables η_k (one per user), compared to M×K for the downlink.
  Reformulating with an auxiliary variable t:

  max  t
  {η_k, t}

  subject to:  t ≤ R^cf_{u,k}    for all k = 1,...,K                  ... (37)

               0 ≤ η_k ≤ 1       for all k

  4.2 Why the Uplink Problem is Quasi-Linear — Proposition 2

  Proposition 2: Problem (37) is quasi-linear (both quasi-convex and
  quasi-concave).

  Proof sketch: From the uplink SINR (Eq. 27):

                       ρ_uf · η_k · (Σ_m γ_mk)²
  SINR_{u,k} = ──────────────────────────────────────────────────────
                 K                                     K    M
   M
            ρ_uf·Σ  η_k'·(Σ_m γ_mk·|φ^H_k'φ_k|)² + ρ_uf·Σ  η_k'·Σ γ_mk·β_mk' + Σ
   γ_mk
                k'≠k                                  k'=1  m=1
  m=1

  For a fixed target t, the constraint SINR_{u,k} ≥ t becomes:

  ρ_uf · η_k · (Σ_m γ_mk)²  ≥  t · [ρ_uf · Σ_{k'≠k} η_k' · (...)  +  ρ_uf ·
  Σ_{k'} η_k' · (...)  +  Σ_m γ_mk]

  Rearranging:

  η_k · [ρ_uf · (Σ_m γ_mk)²]  −  t · Σ_{k'≠k} η_k' · [ρ_uf · (...)]  −  t ·
  Σ_{k'} η_k' · [ρ_uf · (...)]  ≥  t · Σ_m γ_mk

  Every term is LINEAR in {η_k}. There are no quadratic terms, no square roots —
   just weighted sums of the η_k's. Therefore, for a fixed t, this is a set of 
  linear inequalities in the K variables η₁, ..., η_K.

  This means the feasibility subproblem at each bisection step is a Linear 
  Program (LP) — even simpler than the SOCP needed for the downlink!

  4.3 The Complete Uplink Bisection Algorithm

  ┌─────────────────────────────────────────────────────────────────────┐
  │          UPLINK MAX-MIN POWER CONTROL (Bisection + LP)              │
  ├─────────────────────────────────────────────────────────────────────┤
  │                                                                     │
  │  STEP 1 (Initialization):                                           │
  │    t_min = SINR with all users at full power (η_k = 1 for all k)   │
  │    t_max = generous upper bound                                     │
  │    Choose tolerance ε > 0                                           │
  │                                                                     │
  │  STEP 2 (Bisect):                                                   │
  │    Set t = (t_min + t_max) / 2                                      │
  │                                                                     │
  │    Solve the LP feasibility problem:                                │
  │    ┌───────────────────────────────────────────────────────────┐     │
  │    │  Find η₁, ..., η_K such that:                            │     │
  │    │                                                           │     │
  │    │  For all k = 1,...,K:                                     │     │
  │    │    η_k · a_k  −  t · Σ_{k'≠k} η_k' · b_{kk'}  ≥  t·c_k │     │
  │    │                                                           │     │
  │    │  where:                                                   │     │
  │    │    a_k = ρ_uf · (Σ_m γ_mk)²          (signal strength)   │     │
  │    │    b_{kk'} = ρ_uf · (interference terms from k')         │     │
  │    │    c_k = Σ_m γ_mk                     (noise floor)       │     │
  │    │                                                           │     │
  │    │  0 ≤ η_k ≤ 1     for all k                               │     │
  │    └───────────────────────────────────────────────────────────┘     │
  │                                                                     │
  │  STEP 3: If FEASIBLE: t_min = t. If INFEASIBLE: t_max = t.         │
  │                                                                     │
  │  STEP 4: If t_max − t_min < ε: STOP. Otherwise: go to Step 2.      │
  │                                                                     │
  │  ITERATIONS: ⌈log₂((t_max − t_min)/ε)⌉ ≈ 15-20                     │
  │  Each iteration: solve one LP (very fast, even for large K)         │
  │  RESULT: GLOBALLY OPTIMAL                                           │
  └─────────────────────────────────────────────────────────────────────┘

  4.4 Comparison: Downlink vs. Uplink Power Control

  ┌────────────────────┬────────────────────────────┬──────────────────────┐
  │       Aspect       │          Downlink          │        Uplink        │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Variables          │ η_mk (M×K = 4,000 for      │ η_k (K = 40)         │
  │                    │ M=100, K=40)               │                      │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Constraint type    │ Per-AP: Σ_k η_mk·γ_mk ≤ 1  │ Per-user: 0 ≤ η_k ≤  │
  │                    │                            │ 1                    │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Problem type       │ Quasi-concave              │ Quasi-linear         │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Feasibility        │ SOCP (second-order cone)   │ LP (linear program)  │
  │ subproblem         │                            │                      │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Solver needed      │ Interior-point (CVX/MOSEK) │ Any LP solver        │
  │                    │                            │ (linprog)            │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Complexity per     │ O(M³K³)                    │ O(K³)                │
  │ iteration          │                            │                      │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Total solve time   │ Moderate (~seconds for     │ Very fast            │
  │                    │ M=100, K=40)               │ (~milliseconds)      │
  ├────────────────────┼────────────────────────────┼──────────────────────┤
  │ Global optimality  │ Yes                        │ Yes                  │
  └────────────────────┴────────────────────────────┴──────────────────────┘

  4.5 Remark 7 — Weighted Max-Min Extension

  The max-min framework easily extends to weighted max-min:

  max   min  {w_k · R_k}
  {η}   k

  where w_k > 0 is a priority weight for user k. A user with higher priority
  gets a smaller weight (so w_k · R_k is harder to satisfy, forcing the
  optimizer to give that user a higher rate). This allows differentiated service
   quality.

  4.6 The Effect of Power Control — What Happens Physically

  Without power control (equal power), the rate distribution looks like:

  CDF
  1.0 ┤                                    ╱──────
      │                               ╱───╱
  0.8 ┤                          ╱───╱
      │                     ╱───╱        ← wide spread
  0.6 ┤                ╱───╱               (unfair: some users
      │           ╱───╱                     get 20 Mbps, others
  0.4 ┤      ╱───╱                          get 2 Mbps)
      │ ╱───╱
  0.2 ┤╱
      │
  0.0 ┼──────┬──────┬──────┬──────┬──────→ Rate (Mbps)
      0      5     10     15     20

  With max-min power control, the CDF becomes nearly a step function:

  CDF
  1.0 ┤                  │──────────────
      │                  │
  0.8 ┤                  │
      │                  │               ← very narrow spread
  0.6 ┤                  │                 (fair: ALL users get
      │                  │                  ~14 Mbps)
  0.4 ┤                  │
      │                  │
  0.2 ┤                  │
      │                  │
  0.0 ┼──────┬──────┬────┼──┬──────┬────→ Rate (Mbps)
      0      5     10   14  15     20

  The 95%-likely throughput jumps from ~5.5 Mbps to ~14 Mbps — a 2.5×
  improvement, entirely from power control. This is the paper's key message:
  max-min power control makes Cell-Free Massive MIMO deliver uniformly excellent
   service.

  4.7 Summary: The Complete Resource Management Pipeline

                           LARGE-SCALE FADING {β_mk}
                            (measured, changes slowly)
                                      │
                      ┌───────────────┴───────────────┐
                      ▼                               ▼
             PILOT ASSIGNMENT                   RATE COMPUTATION
             (Algorithm 1)                      (Theorems 1 & 2)
                      │                               │
                      ▼                               │
              γ_mk computed                           │
              (channel estimate quality)              │
                      │                               │
                      └───────────────┬───────────────┘
                                      ▼
                             POWER CONTROL
                             (Algorithm 2)
                      ┌───────────────┴───────────────┐
                      ▼                               ▼
                DOWNLINK                         UPLINK
           Bisection + SOCP                  Bisection + LP
           η_mk (M×K vars)                  η_k (K vars)
           Quasi-concave                     Quasi-linear
                      │                               │
                      └───────────────┬───────────────┘
                                      ▼
                           OPTIMAL {η_mk}, {η_k}
                      (globally optimal, max-min fair)
                                      │
                                      ▼
                       TRANSMIT DATA WITH OPTIMAL POWER
                       (η changes on large-scale timescale)

  ---
  This completes the deep dive into Section IV. Shall we move to Section V
  (Small-Cell System baseline) or jump to Section VI (Numerical Results)?

✻ Churned for 9m 49s

❯ /export understanding_paper_sec4_v2.txt 
  ⎿  Conversation exported to: understanding_paper_sec4_v2.txt

❯ Now, move to the section V. 

● Agent(Research small-cell systems baseline)
  ⎿  Done (45 tool uses · 71.0k tokens · 15m 54s)
  (ctrl+o to expand)

● Now here's the complete deep dive into Section V.

  ---
  SECTION V: Small-Cell System (Baseline) — Complete Deep Dive

  ---
  CHUNK 1: Why a Small-Cell Baseline & Architectural Differences

  1.1 The High-Level Picture (Simple Terms)

  To prove Cell-Free Massive MIMO is any good, we need something to compare it
  against. The natural competitor is a small-cell system: same number of APs,
  same area, same total power — but no cooperation. Each user picks the single
  best AP (the one with the strongest average signal) and is served by that AP
  alone. Every other AP is either idle or serving a different user. Think of it
  as 40 tiny independent cell towers, each with its own little "cell."

  The comparison is deliberately fair:
  - Same M APs, same K users, same geography
  - Same total radiated power across the network
  - Same large-scale fading, same shadowing

  Any performance difference comes purely from cooperation vs. isolation.

  1.2 Architectural Comparison

     CELL-FREE MASSIVE MIMO                    SMALL-CELL SYSTEM
     ─────────────────────                    ──────────────────

         ┌─────┐                                  ┌─────┐
         │ CPU │                                  │ CPU │
         └──┬──┘                                  └──┬──┘
      ┌─────┼─────┬─────┐                    ┌──────┼──────┐
      │     │     │     │                    │      │      │
    ┌─┴─┐┌─┴─┐┌──┴┐┌──┴┐               ┌──┴─┐  ┌─┴─┐  ┌┴──┐   (other APs
    │AP₁││AP₂││AP₃││AP₄│               │AP₂ │  │AP₅│  │AP₉│    are idle)
    └─┬─┘└─┬─┘└──┬┘└──┬┘               └──┬─┘  └─┬─┘  └┬──┘
      ╲  ╲╱ ╱╲  ╱╲  ╱                     │      │      │
       ╲╱  ╲╱  ╲╱  ╲╱                     │      │      │
      ┌─┴─┐   ┌─┴─┐                    ┌──┴─┐  ┌─┴─┐  ┌┴──┐
      │UE₁│   │UE₂│                    │UE₁ │  │UE₂│  │UE₃│
      └───┘   └───┘                    └────┘  └───┘  └───┘

    ALL APs serve ALL users              Each user served by ONE AP
    (cooperative, no cells)              (independent, creates cells)

  1.3 AP Selection — Equation (38)

  For each user k, the system selects the available AP with the largest average
  received signal power:

  m_k = arg max       β_mk                                           ... (38)
       m ∈ {available APs}

  The selection is done greedily, one user at a time in random order. Once an AP
   is assigned to a user, it becomes unavailable for other users. This avoids
  two users sharing the same AP.

  Numerical example: With M = 5 APs, K = 3 users:

  β matrix:     U₁    U₂    U₃
     AP₁     [ 0.50  0.02  0.10 ]
     AP₂     [ 0.03  0.40  0.05 ]
     AP₃     [ 0.20  0.30  0.01 ]
     AP₄     [ 0.01  0.05  0.45 ]
     AP₅     [ 0.10  0.15  0.20 ]

  Round 1 (user order: U₁ first): U₁ picks AP₁ (β₁₁ = 0.50 is largest in column
  1). AP₁ removed.

  Round 2 (U₂ next): U₂ picks AP₂ (β₂₂ = 0.40, since AP₁ is taken). AP₂ removed.

  Round 3 (U₃ last): U₃ picks AP₄ (β₄₃ = 0.45). AP₄ removed.

  APs 3 and 5 are unused — their power is wasted.

  Important modeling assumption: The paper assumes no handovers within the
  observation period. This may make the small-cell performance slightly
  overoptimistic (in practice, handovers cause additional overhead).

  1.4 The Fundamental Problem: No Channel Hardening

  This is the key difference that cascades into everything else.

  Cell-Free: The effective downlink channel for user k is:

  a_k = Σ_{m=1}^{M} √η_mk · g_mk · ĝ*_mk     ← sum of M random terms

  By the law of large numbers, a_k → E{a_k} as M grows. The channel hardens.

  Small-Cell: The effective channel is:

  a_k^{sc} = g_{m_k,k}     ← a SINGLE Rayleigh fading scalar

  There is no sum, no averaging, no law of large numbers. The channel is:

  g_{m_k,k} = √β_{m_k,k} · h_{m_k,k}     where h_{m_k,k} ~ CN(0,1)

  The instantaneous channel power |g_{m_k,k}|² = β_{m_k,k} · |h_{m_k,k}|²
  fluctuates wildly because |h_{m_k,k}|² ~ Exp(1) has a coefficient of variation
   of 100%.

           Cell-Free:                          Small-Cell:
           |a_k|² concentrated                 |g_{m_k,k}|² wildly random

     P(x)                                P(x)
      │ █                                  │╲
      │ █ █                                │ ╲
      │ █ █ █                              │  ╲
      │█ █ █ █                             │   ╲
      │█ █ █ █ █                           │    ╲
      │█ █ █ █ █ █                         │     ╲
      ┼─┼─┼─┼─┼─┼─┼──→ |a_k|²           ┼──────╲──────→ |g|²
          ↑                               exponential distribution
      tightly peaked                      (deep fades likely)

  Consequence: Since the channel does NOT harden, the user cannot just use
  E{channel} for decoding — it must know the instantaneous channel realization.
  This requires downlink pilots.

  ---
  CHUNK 2: Downlink Transmission in Small Cells

  2.1 The Need for Downlink Training

  Unlike Cell-Free, small-cell systems require both uplink and downlink pilot 
  phases:

  ┌─────────────────────────────────────────────────────────────────┐
  │               One Coherence Interval (τ_c = 200)               │
  ├──────────┬──────────┬──────────────────────────────────────────-─┤
  │  UL      │  DL      │  Data (UL + DL)                           │
  │  pilots  │  pilots  │                                            │
  │  (τ^sc_u)│ (τ^sc_d) │  (τ_c − τ^sc_u − τ^sc_d)                │
  │          │          │                                            │
  │  User→AP │  AP→User │  AP ↔ User                                │
  │  (AP     │  (User   │                                            │
  │  estimates│ estimates│                                            │
  │  channel) │ channel) │                                            │
  └──────────┴──────────┴────────────────────────────────────────────┘

  Compare with Cell-Free:
  ┌─────────────────────────────────────────────────────────────────┐
  │  UL pilots    │    Data (UL + DL)                               │
  │  (τ_cf)       │    (τ_c − τ_cf)                                 │
  │               │    ← NO DL pilots needed (channel hardening)    │
  └───────────────┴─────────────────────────────────────────────────┘

  Remark 8 from the paper: In small-cell systems, since only one single-antenna
  AP transmits to a given user, the concept of "conjugate beamforming" becomes
  void. Downlink transmission is simply: transmit the data symbol scaled by a
  power control coefficient. Channel estimation at the user is required for
  demodulation because there is no channel hardening.

  2.2 Downlink Channel Estimation at the User — Equation (39)–(40)

  The assigned AP m_k sends a downlink pilot sequence ψ_k of length τ^sc_d. The
  user estimates the channel g_{m_k,k} using MMSE estimation. The estimate is:

  ĝ_{m_k,k} = g_{m_k,k} − ε_{m_k,k}                                 ... (39)

  where ε_{m_k,k} is the estimation error. The estimate and error are
  independent Gaussians:

  ĝ_{m_k,k} ~ CN(0, γ̃_{m_k,k})

  ε_{m_k,k} ~ CN(0, β_{m_k,k} − γ̃_{m_k,k})

  The estimate variance is:

                      τ^sc_d · ρ_{sc,p} · β²_{m_k,k}
  γ̃_{m_k,k} = ─────────────────────────────────────────────────────      ...
  (40)
                τ^sc_d · ρ_{sc,p} · Σ_{k': φ^H_k' ψ_k ≠ 0} β_{m_k,k'} + 1

  This looks similar to the Cell-Free MMSE estimate, but there are two critical
  differences:
  1. It uses the downlink pilot power ρ_{sc,p} and length τ^sc_d
  2. The estimate is at the user, not the AP
  3. Pilot contamination comes from other users whose APs send correlated pilots

  2.3 Received Downlink Signal — Equation (41)

  The chosen AP m_k transmits the data symbol q_k scaled by a power control
  coefficient η_{d,k}:

  x_{m_k} = √ρ^sc_d · √η_{d,k} · q_k

  where 0 ≤ η_{d,k} ≤ 1. The k-th user receives:

                                          K
  y_k = √ρ^sc_d · g_{m_k,k} · √η_{d,k} · q_k  +  √ρ^sc_d · Σ   g_{m_{k'},k} ·
  √η_{d,k'} · q_k'  +  w_k
                                         k'≠k
        └──────────── desired signal ──────────┘    └──────────── inter-cell
  interference ──────────┘   └noise┘

  The user splits the desired signal using its channel estimate:

  y_k = √ρ^sc_d · ĝ_{m_k,k} · √η_{d,k} · q_k          ← known channel × desired
  symbol
      + √ρ^sc_d · ε_{m_k,k} · √η_{d,k} · q_k            ← estimation error ×
  desired symbol
        K
      + √ρ^sc_d · Σ   g_{m_{k'},k} · √η_{d,k'} · q_k'   ← interference from
  other cells
                 k'≠k
      + w_k                                                ← noise
                                                                           ...
  (41)

  2.4 Achievable Downlink Rate — Equations (42)–(44)

  Since the user knows the instantaneous channel estimate ĝ_{m_k,k}, the
  achievable rate is the ergodic capacity (expectation of log over the fading):

                      ⎧           ⎛                 ρ^sc_d · η_{d,k} ·
  |ĝ_{m_k,k}|²                        ⎞ ⎫
  R^sc_{d,k} = E     ⎨ log₂ ⎜ 1 +
  ──────────────────────────────────────────────────────── ⎟ ⎬       ... (42)
                      ⎩           ⎜     ρ^sc_d·η_{d,k}·(β_{m_k,k}−γ̃_{m_k,k}) +
  ρ^sc_d·Σ_{k'≠k} η_{d,k'}·β_{m_{k'},k} + 1  ⎟ ⎭
                                  ⎝
                               ⎠

  Key observation: The term |ĝ_{m_k,k}|² in the numerator is random
  (exponentially distributed). We must take the expectation E{log₂(1 + ...)}
  over this randomness. This is what makes the rate expression fundamentally
  different from Cell-Free.

  Since |ĝ_{m_k,k}|² ~ Exp(1/γ̃_{m_k,k}), the expectation has a closed-form in
  terms of the exponential integral function.

  2.5 The Exponential Integral — Why It Appears

  What is Ei(x)? The exponential integral is a special function defined as:

  Ei(x) = − ∫_{−x}^{∞} (e^{−t} / t) dt     (for x > 0, Cauchy principal value)

  The related function E₁(x) = −Ei(−x) = ∫_x^∞ (e^{−t}/t) dt is implemented as
  expint(x) in MATLAB.

  Why it appears here: We need to compute E{log₂(1 + γ̄ · X)} where X ~ Exp(1):

  E{log₂(1 + γ̄X)} = (1/ln 2) · ∫₀^∞ ln(1 + γ̄x) · e^{−x} dx

  Integration by parts with u = ln(1 + γ̄x), dv = e^{−x}dx:

  = (1/ln 2) · [−ln(1+γ̄x)·e^{−x}]₀^∞  +  (1/ln 2) · ∫₀^∞ (γ̄ · e^{−x}) / (1+γ̄x)
  dx

  = (1/ln 2) · ∫₀^∞ (γ̄ · e^{−x}) / (1+γ̄x) dx

  Substituting t = 1 + γ̄x (so x = (t−1)/γ̄, dx = dt/γ̄):

  = (1/ln 2) · ∫₁^∞ e^{−(t−1)/γ̄} / t · dt

  = (1/ln 2) · e^{1/γ̄} · ∫₁^∞ e^{−t/γ̄} / t · dt

  Substituting u = t/γ̄:

  = (1/ln 2) · e^{1/γ̄} · ∫_{1/γ̄}^∞ e^{−u} / u · du

  = (1/ln 2) · e^{1/γ̄} · E₁(1/γ̄)

  = −(log₂ e) · e^{1/γ̄} · Ei(−1/γ̄)

  This gives the closed-form rate — Equation (43):

  R^sc_{d,k} = −(log₂ e) · e^{1/γ̄_{m_k,k}} · Ei(−1/γ̄_{m_k,k})         ... (43)

  where the effective SINR parameter γ̄_{m_k,k} is — Equation (44):

                      ρ^sc_d · η_{d,k} · γ̃_{m_k,k}
  γ̄_{m_k,k} = ──────────────────────────────────────────────────────      ...
  (44)
                                                     K
                ρ^sc_d · η_{d,k} · (β_{m_k,k} − γ̃_{m_k,k})  +  ρ^sc_d · Σ
  η_{d,k'} · β_{m_{k'},k}  +  1
                                                    k'≠k

  2.6 Understanding γ̄ — The Effective SINR

  ┌──────────────────────────────┬───────────────────────────────────────────┐
  │    Term in γ̄ denominator     │             Physical meaning              │
  ├──────────────────────────────┼───────────────────────────────────────────┤
  │ ρ^sc_d · η_{d,k} ·           │ Self-interference from channel estimation │
  │ (β_{m_k,k} − γ̃_{m_k,k})      │  error                                    │
  ├──────────────────────────────┼───────────────────────────────────────────┤
  │ ρ^sc_d · Σ_{k'≠k} η_{d,k'} · │ Inter-cell interference (other APs'       │
  │  β_{m_{k'},k}                │ signals leaking to user k)                │
  ├──────────────────────────────┼───────────────────────────────────────────┤
  │ 1                            │ Noise                                     │
  └──────────────────────────────┴───────────────────────────────────────────┘

  Comparison with Cell-Free SINR: The Cell-Free numerator has (Σ_m √η_mk ·
  γ_mk)² — a coherent sum over M APs, giving O(M²) scaling. The small-cell
  numerator has just η_{d,k} · γ̃_{m_k,k} — a single AP's contribution, giving
  O(1) scaling. This is the fundamental performance gap.

  ---
  CHUNK 3: Uplink Transmission in Small Cells

  3.1 Uplink Channel Estimation

  In the uplink, user k sends pilot sequence ψ_k of length τ^sc_u to its serving
   AP m_k. The AP estimates the channel using MMSE:

                      τ^sc_u · ρ_{sc,p} · β²_{m_k,k}
  μ_{m_k,k} = ──────────────────────────────────────────────────────      ...
  (49)
                τ^sc_u · ρ_{sc,p} · Σ_{k': φ^H_k' ψ_k ≠ 0} β_{m_k,k'} + 1

  3.2 Uplink Received Signal and Matched Filtering

  AP m_k receives signals from all K users (not just its assigned user):

                           K
  y_{m_k} = √ρ^sc_u ·  Σ  g_{m_k,k'} · √η_{u,k'} · q_k'  +  w_{m_k}
                      k'=1

  The AP applies matched filtering with its channel estimate:

  r_k = ĝ*_{m_k,k} · y_{m_k}

  3.3 Achievable Uplink Rate — Equation (47)

  Following the same ergodic capacity derivation as the downlink:

  R^sc_{u,k} = −(log₂ e) · e^{1/γ̄'_{m_k,k}} · Ei(−1/γ̄'_{m_k,k})       ... (47)

  where the effective uplink SINR is — Equation (48):

                       ρ^sc_u · η_{u,k} · μ_{m_k,k}
  γ̄'_{m_k,k} = ──────────────────────────────────────────────────────     ...
  (48)
                                                        K
                 ρ^sc_u · η_{u,k} · (β_{m_k,k} − μ_{m_k,k})  +  ρ^sc_u · Σ
  η_{u,k'} · β_{m_k,k'}  +  1
                                                       k'≠k

  Structure is identical to the downlink, with:
  - μ_{m_k,k} replacing γ̃_{m_k,k} (uplink MMSE vs. downlink MMSE)
  - η_{u,k} replacing η_{d,k} (uplink vs. downlink power control)
  - β_{m_k,k'} as the interference term (how strongly AP m_k hears interfering
  user k')

  3.4 Rate Comparison: Cell-Free vs. Small-Cell

  ┌─────────────────┬───────────────────────────┬───────────────────────────┐
  │     Aspect      │      Cell-Free Rate       │      Small-Cell Rate      │
  ├─────────────────┼───────────────────────────┼───────────────────────────┤
  │ Formula         │ log₂(1 + SINR)            │ −(log₂e) · e^{1/γ̄} ·      │
  │                 │                           │ Ei(−1/γ̄)                  │
  ├─────────────────┼───────────────────────────┼───────────────────────────┤
  │ Why different   │ Channel hardens → SINR is │ Channel random → must     │
  │                 │  deterministic            │ average over fading       │
  ├─────────────────┼───────────────────────────┼───────────────────────────┤
  │ SINR scaling    │ Numerator ~ O(M²)         │ Numerator ~ O(1)          │
  ├─────────────────┼───────────────────────────┼───────────────────────────┤
  │ Macro-diversity │ Yes (all M APs            │ No (only 1 AP)            │
  │                 │ contribute)               │                           │
  ├─────────────────┼───────────────────────────┼───────────────────────────┤
  │ Pre-log factor  │ (τ_c − τ_cf) / τ_c        │ (τ_c − τ^sc_u − τ^sc_d) / │
  │                 │                           │  τ_c                      │
  └─────────────────┴───────────────────────────┴───────────────────────────┘

  3.5 Numerical Feel for the Ei-Based Rate

  To build intuition, here are some values of the Ei-based rate function f(γ̄) =
  −(log₂e) · e^{1/γ̄} · Ei(−1/γ̄):

  ┌────────────────────┬──────────────────┬──────────────────────────┐
  │ γ̄ (effective SINR) │ f(γ̄) (bits/s/Hz) │ log₂(1+γ̄) for comparison │
  ├────────────────────┼──────────────────┼──────────────────────────┤
  │ 0.1                │ 0.11             │ 0.14                     │
  ├────────────────────┼──────────────────┼──────────────────────────┤
  │ 1.0                │ 0.68             │ 1.00                     │
  ├────────────────────┼──────────────────┼──────────────────────────┤
  │ 5.0                │ 1.94             │ 2.58                     │
  ├────────────────────┼──────────────────┼──────────────────────────┤
  │ 10.0               │ 2.76             │ 3.46                     │
  ├────────────────────┼──────────────────┼──────────────────────────┤
  │ 20.0               │ 3.58             │ 4.39                     │
  └────────────────────┴──────────────────┴──────────────────────────┘

  The Ei-based rate is always lower than log₂(1+γ̄). The gap represents the
  penalty for fading randomness — averaging log(1+γ̄X) over random X gives less
  than log(1+γ̄·E{X}) by Jensen's inequality. Cell-Free avoids this penalty
  through channel hardening.

  ---
  CHUNK 4: Max-Min Power Control for Small Cells & Fair Comparison Setup

  4.1 Downlink Max-Min Power Control — Equations (45)–(46)

  The small-cell downlink max-min problem:

  max       min      R^sc_{d,k}
  {η_{d,k}}  k=1,...,K

  subject to:  0 ≤ η_{d,k} ≤ 1     for all k                         ... (45)

  Since R^sc_{d,k} is monotonically increasing in γ̄_{m_k,k} (and the Ei-based
  function is monotone), this is equivalent to:

  max       min      γ̄_{m_k,k}
  {η_{d,k}}  k=1,...,K

  subject to:  0 ≤ η_{d,k} ≤ 1                                       ... (46)

  This is a quasi-linear program — identical in structure to the Cell-Free
  uplink problem. For a fixed target t, the constraint γ̄_{m_k,k} ≥ t gives:

  ρ^sc_d · η_{d,k} · γ̃_{m_k,k}  ≥  t · [ρ^sc_d · η_{d,k} · (β_{m_k,k} −
  γ̃_{m_k,k})  +  ρ^sc_d · Σ_{k'≠k} η_{d,k'} · β_{m_{k'},k}  +  1]

  Rearranging:

  η_{d,k} · [γ̃_{m_k,k} − t·(β_{m_k,k} − γ̃_{m_k,k})]  −  t · Σ_{k'≠k} η_{d,k'} ·
  β_{m_{k'},k}  ≥  t / ρ^sc_d

  This is linear in {η_{d,k}} → solved by bisection + LP. Much simpler than the
  Cell-Free downlink (which requires SOCP).

  4.2 Uplink Max-Min Power Control — Equation (50)

  Same structure:

  max       min      γ̄'_{m_k,k}
  {η_{u,k}}  k=1,...,K

  subject to:  0 ≤ η_{u,k} ≤ 1                                       ... (50)

  Also a quasi-linear program, solved by bisection + LP.

  Key simplification vs. Cell-Free downlink: Small-cell power control has only K
   variables (one per user). Cell-Free downlink has M×K variables (one per
  AP-user pair). This is because in small cells each user is served by exactly
  one AP, so there's only one power coefficient per user.

  4.3 Fair Comparison Setup — Equal Total Radiated Power

  The paper carefully ensures a fair comparison between Cell-Free and small-cell
   systems:

  Total radiated power equalization:

  Cell-Free:  M APs × ρ^cf_d each = M · ρ^cf_d  (total downlink power)
  Small-Cell: K APs × ρ^sc_d each = K · ρ^sc_d  (only K APs are active)

  Setting equal:  M · ρ^cf_d = K · ρ^sc_d

  Therefore:  ρ^sc_d = (M/K) · ρ^cf_d

  With M = 100, K = 40: Each small-cell AP gets 2.5× more power than each
  Cell-Free AP. This compensates for the fact that in small cells, fewer APs are
   active.

  Similarly for uplink: ρ^sc_u = ρ^cf_u (same per-user power, since K users
  transmit in both cases).

  Pilot power: ρ_{sc,p} = ρ^cf_p (same pilot power per symbol).

  4.4 Pre-Log Factor Comparison

  The net throughput accounts for training overhead:

  Cell-Free:   S^cf_{A,k} = B · (1 − τ_cf/τ_c) / 2 · R^cf_{A,k}        ... (56)

  Small-Cell:  S^sc_{A,k} = B · (1 − (τ^sc_d + τ^sc_u)/τ_c) / 2 · R^sc_{A,k}
  ... (57)

  where A ∈ {d, u} (downlink/uplink), B = 20 MHz bandwidth, and the factor 1/2
  splits the remaining samples equally between UL and DL.

  With τ_c = 200, τ_cf = τ^sc_d = τ^sc_u = 20:

  Cell-Free pre-log:   (1 − 20/200) / 2 = 0.90/2 = 0.45
  Small-Cell pre-log:  (1 − (20+20)/200) / 2 = 0.80/2 = 0.40

  Cell-Free has a 12.5% higher pre-log factor simply from needing fewer pilots.
  This advantage grows if τ^sc_d is large.

  4.5 Why Correlated Shadow Fading Devastates Small Cells

  This is one of the paper's most striking findings. Let me explain with an
  analogy.

  Uncorrelated shadow fading: Imagine each AP is behind a door that is randomly
  open or closed (independently). User k walks through the building looking for
  the best AP. With 100 doors, it's very likely that at least one nearby door is
   open → user finds a good AP.

  Correlated shadow fading: Now imagine that nearby doors tend to be open/closed
   together (they share the same wall section). If the user's nearest door is
  closed, the next 5–10 nearby doors are probably also closed → the user must
  travel much farther to find an open door → much worse service.

  Mathematically: The shadow fading model from Eq. (54) is:

  z_mk = √δ · a_m + √(1−δ) · b_k                                    ... (54)

  where:
  - a_m ~ N(0,1): shadowing component tied to AP m (same for all users)
  - b_k ~ N(0,1): shadowing component tied to user k (same for all APs)
  - δ ∈ [0,1]: mixing parameter

  The correlation between APs:

  E{a_m · a_{m'}} = 2^{−d_a(m,m')/d_decorr}                          ... (55)

  When decorrelation distance d_decorr = 100m and APs are 50m apart, the
  correlation is 2^{−0.5} ≈ 0.71 — very high. This means:

  For small cells: The user picks max_m β_mk. Under correlated shadowing, all
  nearby APs have similar β_mk values. The selection gain (improvement from
  picking the best out of many) shrinks dramatically. The best AP is barely
  better than average.

  For Cell-Free: ALL M APs contribute. The sum Σ_m γ_mk includes contributions
  from APs across the entire 1km × 1km area. APs more than ~300m apart are
  essentially uncorrelated (2^{−3} ≈ 0.125). With 100 APs spread over 1km²,
  there are always many uncorrelated clusters → the sum is robust to local
  shadowing correlation.

  Quantitative result from the paper:

                            95%-likely DL throughput
                       ┌────────────────┬────────────────┐
                       │  Uncorrelated  │   Correlated   │
  ├────────────────────┼────────────────┼────────────────┤
  │ Cell-Free mMIMO    │   ~14 Mbps     │   ~11 Mbps     │  (↓ 21%)
  │ Small-Cell         │   ~2.1 Mbps    │   ~1.1 Mbps    │  (↓ 48%)
  ├────────────────────┼────────────────┼────────────────┤
  │ CF / SC ratio      │    6.7×        │    10×          │
  └────────────────────┴────────────────┴────────────────┘

  Cell-Free loses 21% but small cells lose 48%. The ratio jumps from ~7× to
  ~10×. Correlated shadowing is where Cell-Free's distributed architecture pays 
  off most.

  4.6 Summary: Complete Section V at a Glance

  ┌──────────────────────────────────────────────────────────────────────┐
  │                     SMALL-CELL SYSTEM                                │
  ├──────────────────────────────────────────────────────────────────────┤
  │                                                                      │
  │  Architecture:  Each user → 1 AP (best β_mk). No cooperation.       │
  │                                                                      │
  │  Channel:       g_{m_k,k} = √β_{m_k,k} · h_{m_k,k}                │
  │                 Single Rayleigh scalar. No hardening.                │
  │                                                                      │
  │  Pilots:        UL (τ^sc_u) + DL (τ^sc_d) — more overhead than CF   │
  │                                                                      │
  │  DL Rate:       R = −(log₂e)·e^{1/γ̄}·Ei(−1/γ̄)    ← Ei function   │
  │                 (ergodic capacity over Rayleigh fading)              │
  │                                                                      │
  │  UL Rate:       Same Ei-based formula with uplink SINR              │
  │                                                                      │
  │  Power Ctrl:    Quasi-linear (bisection + LP), only K variables     │
  │                                                                      │
  │  Fair setup:    ρ^sc = (M/K)·ρ^cf (equal total radiated power)      │
  │                                                                      │
  │  Weakness:      No macro-diversity → crushed by correlated shadow   │
  │                 fading. 95%-likely throughput 5–10× worse than CF.   │
  │                                                                      │
  │  Advantage:     Much less backhaul needed (no AP cooperation).       │
  │                 Simpler implementation.                               │
  └──────────────────────────────────────────────────────────────────────┘

  ---
  Ready to move to Section VI (Numerical Results) or shall we start implementing
   in MATLAB?

✻ Worked for 14m 1s