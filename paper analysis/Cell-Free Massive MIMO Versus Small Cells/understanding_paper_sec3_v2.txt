
╭─── Claude Code v2.1.63 ──────────────────────────────────────────────────────╮
│                                                    │ Tips for getting        │
│             Welcome back Tech Shottify!            │ started                 │
│                                                    │ Run /init to create a … │
│                       ▐▛███▜▌                      │ ─────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity         │
│                        ▘▘ ▝▝                       │ No recent activity      │
│                                                    │                         │
│               Opus 4.6 · Claude Max                │                         │
│ F:\Codes\Awesome-Wireless-Communications-Paper-Im… │                         │
╰──────────────────────────────────────────────────────────────────────────────╯

❯ I want you to implement this paper:                                       
   CATEGORY A: Core Cell-Free MIMO — Foundations (6 Papers)                 
                                                                            
    ---                                                                     
    Paper 1 — THE Founding Paper                                            
                                                                            
    "Cell-Free Massive MIMO Versus Small Cells"                             
                                                                            
    ┌────────────────┬───────────────────────────────────────────────────── 
  ───┐                                                                      
    │                │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Authors        │ H. Q. Ngo, A. Ashikhmin, H. Yang, E. G. Larsson, T.  
  L. │                                                                      
    │                │  Marzetta                                            
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Journal        │ IEEE Trans. Wireless Commun. (Q1, IF: 10.7)          
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Year /         │ 2017 / ~1,500+                                       
     │                                                                      
    │ Citations      │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ In your        │ Yes                                                  
     │                                                                      
    │ folder?        │                                                      
     │                                                                      
    ├────────────────┼───────────────────────────────────────────────────── 
  ───┤                                                                      
    │ Code           │ https://arxiv.org/abs/1602.08232                     
     │                                                                      
    └────────────────┴───────────────────────────────────────────────────── 
  ───┘                                                                      
                                                                            
    What you'll reproduce: System model with distributed single-antenna     
  APs, TDD                                                                  
    protocol, conjugate beamforming (CB) uplink/downlink, max-min power     
  control,                                                                  
    CDF of per-user throughput vs. small cells.                             
                                                                            
    What you'll learn: The entire CF-mMIMO system model from scratch —      
  channel                                                                   
    estimation, pilot contamination, coherent transmission, favorable       
  propagation,                                                              
     and why cell-free eliminates cell edges.                               
                                                                            
  -----------------------                                                   
  For this, first, you need to read this paper:                             
  F:\Codes\Awesome-Wireless-Communications-Paper-Implementation\papers\Cell 
  -Free\001_All Paper(without review paper)\Cell-Free Massive MIMO Versus   
  Small Cells.pdf                                                           
  ---------------------                                                     
  First, you need to read the pdf.                                          
  and give me a very high level overview without any code summerizing the   
  key contribution of the each sections of the paper.                       
  ------------------                                                        
  After that , we will deep dive in each section and finally we will        
  implement these in Matlab code.                                           
  Make sure you understand the figure very well.                            

● Let me read the paper first.

● Read 1 file (ctrl+o to expand)

● Bash(which pdftoppm 2>/dev/null; which pdftotext 2>/dev/null; pip show PyPDF2
      2>/dev/null | head -2; pip show pymupdf 2>/dev/null | head -2; python -c
      "import fitz;…)
  ⎿  Error: Exit code 1
     /mingw64/bin/pdftotext

     /mingw64/bin/pdftotext

● Bash(pdftotext "F:/Codes/Awesome-Wireless-Communications-Paper-Implementation/
      papers/Cell-Free/001_All Paper(without review paper)/Cell-Free Massive
      MIMO Versus Smal…)
  ⎿  IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. XX, NO. X, XXX 2017

     1
     … +426 lines (ctrl+o to expand)

● Read 2 files (ctrl+o to expand)

● Now I have a thorough understanding of the entire paper. Let me provide the
  high-level overview.

  ---
  Paper Overview: "Cell-Free Massive MIMO versus Small Cells" (Ngo et al., 2017)

  The Big Idea (Abstract)

  Instead of having a few powerful base stations (each creating "cells"),
  scatter hundreds of simple single-antenna access points (APs) across a wide
  area. All APs cooperate phase-coherently through a central processing unit
  (CPU) to serve a much smaller number of users simultaneously on the same 
  time-frequency resource. There are no cells, no cell boundaries — hence
  "Cell-Free."

  The key result: Cell-Free Massive MIMO provides ~5x improvement in 95%-likely
  per-user throughput over small cells (uncorrelated shadowing), and ~10x 
  improvement under correlated shadowing.

  ---
  Section-by-Section Breakdown

  Section I: Introduction

  Key Contribution: Sets up the motivation — why go cell-free?

  - Collocated Massive MIMO (all antennas at one base station) works well, but
  users at cell edges still suffer.
  - Distributed Massive MIMO (spread antennas out) can exploit macro-diversity
  against shadow fading — users are always close to some AP.
  - Prior works on distributed MIMO / network MIMO assumed perfect CSI
  (unrealistic). This paper is the first to rigorously analyze Cell-Free Massive
   MIMO with imperfect CSI, pilot contamination, and optimal power control.
  - The paper distinguishes itself from CoMP/DAS by operating in the Massive 
  MIMO regime: M APs >> K users, with simple conjugate beamforming.

  ---
  Section II: Cell-Free Massive MIMO System Model

  Key Contribution: Defines the complete system architecture.

  - M APs, K users, all single-antenna, randomly distributed in a D x D km area.
  - All APs connect to a CPU via backhaul.
  - TDD protocol with 3 phases per coherence interval:
    a. Uplink training (users send pilots to APs)
    b. Downlink data (APs beamform to users)
    c. Uplink data (users transmit, APs detect)
  - Channel model: g_mk = sqrt(beta_mk) * h_mk where beta_mk = large-scale
  fading, h_mk ~ CN(0,1) = small-scale fading.
  - Section II-A (Uplink Training): Users send pilot sequences of length tau_cf.
   MMSE channel estimation is derived. If tau_cf < K, pilots must be reused →
  pilot contamination. The key estimate formula is g_hat_mk = c_mk * y_{p,mk}
  where c_mk depends on all large-scale fading coefficients of users sharing the
   same pilot.
  - Section II-B (Downlink Data): APs use conjugate beamforming — each AP simply
   multiplies the data symbol by the conjugate of its channel estimate. No CSI
  sharing between APs. Users do not need downlink pilots because of channel 
  hardening (the effective channel gain concentrates around its mean).
  - Section II-C (Uplink Data): Each AP applies matched filtering (multiply
  received signal by conjugate of channel estimate) and forwards the result to
  the CPU for detection.

  ---
  Section III: Performance Analysis

  Key Contribution: Derives exact closed-form rate expressions.

  - Section III-A (Large-M Analysis): When M → ∞, by Tchebyshev's theorem, the
  effects of noise, non-coherent interference, and small-scale fading all 
  vanish. Only pilot contamination remains (interference from users sharing the
  same pilot). This is the "favorable propagation" phenomenon.
  - Section III-B (Finite-M Achievable Rates):
    - Theorem 1 (Downlink Rate): Closed-form SINR expression for any finite M,
  K. The numerator has the squared sum of sqrt(eta_mk) * gamma_mk, and the
  denominator captures beamforming uncertainty + multi-user interference +
  noise. This is Eq. (24) — the central equation of the paper.
    - Theorem 2 (Uplink Rate): Similar closed-form for uplink, Eq. (27). The
  uplink has simpler power control (only K coefficients eta_k vs. M×K for
  downlink).
    - Remark 4 / Figure 2: Shows that the gap between "user knows only
  statistics" vs. "user knows actual channel" is small — confirming channel 
  hardening makes downlink pilots unnecessary.

  ---
  Section IV: Pilot Assignment and Power Control

  Key Contribution: Algorithms for resource management.

  - Section IV-A (Greedy Pilot Assignment):
    - Start with random assignment of tau_cf orthogonal pilots to K users.
    - Iteratively find the worst-rate user, re-assign its pilot to minimize
  pilot contamination (measured by summing large-scale fading of co-pilot users
  across all APs).
    - Simple, effective, runs on large-scale fading timescale (infrequent
  updates).
  - Section IV-B (Max-Min Power Control):
    - Downlink (Algorithm 2): Find power coefficients eta_mk (M×K variables) to
  maximize the minimum user rate. The problem is quasi-concave → solved by
  bisection + SOCP (second-order cone program). Globally optimal.
    - Uplink: Find eta_k (K variables) to maximize the minimum user rate. The
  problem is quasi-linear → solved by bisection + linear program. Even simpler.
    - Max-min fairness ensures uniformly good service — no user is left behind
  regardless of location.

  ---
  Section V: Small-Cell System (Baseline)

  Key Contribution: Defines the comparison baseline.

  - Each user is served by only one AP (the one with best large-scale fading).
  No cooperation between APs.
  - Unlike Cell-Free, there is no channel hardening (single Rayleigh fading
  scalar), so both uplink and downlink pilots are needed.
  - Achievable rate is expressed using the exponential integral function Ei(·),
  Eq. (43) and (47).
  - Max-min power control is also quasi-linear → solvable by bisection.
  - Fair comparison: total radiated power is kept equal (rho_sc = (M/K) * 
  rho_cf).

  ---
  Section VI: Numerical Results

  Key Contribution: Quantitative comparison via CDF plots.

  Setup: M=100 APs, K=40 users, 1km × 1km area, 1.9 GHz carrier, 20 MHz
  bandwidth, coherence interval = 200 samples. The area wraps around (toroidal)
  to avoid boundary effects.

  Key Figures:

  ┌────────┬────────────────────────────────────────────────────────────────┐
  │ Figure │                         What it shows                          │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 2 │ Rate vs. M: validates channel hardening (statistics-only vs.   │
  │        │ genie-aided)                                                   │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │        │ CDF of DL throughput (greedy pilot + max-min power control):   │
  │ Fig. 3 │ CF-mMIMO 95%-likely ≈ 14 Mbps vs. small-cell ≈ 2 Mbps          │
  │        │ (uncorrelated); gap widens with correlated shadowing           │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 4 │ Same as Fig. 3 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 5 │ CDF of DL throughput without power control: CF still better,   │
  │        │ but the CDF is much more spread out                            │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 6 │ Same as Fig. 5 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 7 │ CDF with random pilot assignment + max-min PC: ~20% worse than │
  │        │  greedy at 95%-likely                                          │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 8 │ Same as Fig. 7 but for uplink                                  │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig. 9 │ Effective number of APs per user: only ~10-20 out of 100 APs   │
  │        │ contribute 95% of the power                                    │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig.   │ Avg DL throughput vs. K (number of users)                      │
  │ 10     │                                                                │
  ├────────┼────────────────────────────────────────────────────────────────┤
  │ Fig.   │ Avg DL throughput vs. M (number of APs)                        │
  │ 11     │                                                                │
  └────────┴────────────────────────────────────────────────────────────────┘

  Key takeaways from figures:
  1. Power control is far more important than pilot assignment (factor of ~2.5x
  improvement at 95%-likely).
  2. Greedy pilot assignment gives ~20% gain over random.
  3. Cell-Free is robust to correlated shadowing; small-cell is devastated by
  it.
  4. Even though 100 APs exist, only ~10-20 effectively serve each user (natural
   sparsity).

  ---
  Section VII: Conclusion

  - Cell-Free Massive MIMO massively outperforms small cells.
  - Shadow fading correlation hurts small cells far more than Cell-Free.
  - The trade-off: Cell-Free requires more backhaul than small cells.

  Appendix A & B

  - Appendix A: Full proof of Theorem 1 (downlink rate) — derives DS, BU, and UI
   terms step by step.
  - Appendix B: Proves that the downlink max-min problem is quasi-concave,
  enabling the bisection approach.

  ---
  Summary of What We'll Implement

  ┌─────────────────────┬───────────────────────────────────────────────────┐
  │      Component      │                    Description                    │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Channel generation  │ Large-scale fading (3-slope path loss +           │
  │                     │ log-normal shadowing, correlated & uncorrelated)  │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ MMSE channel        │ With pilot contamination                          │
  │ estimation          │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Conjugate           │ Distributed precoding at each AP                  │
  │ beamforming (DL)    │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Matched filtering   │ Distributed detection at each AP                  │
  │ (UL)                │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Closed-form rate    │ Theorems 1 & 2, Eqs. (24) and (27)                │
  │ computation         │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Greedy pilot        │ Algorithm 1                                       │
  │ assignment          │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Max-min power       │ DL: bisection + SOCP; UL: bisection + LP          │
  │ control             │                                                   │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ Small-cell baseline │ AP selection, rate expressions with Ei(·), power  │
  │                     │ control                                           │
  ├─────────────────────┼───────────────────────────────────────────────────┤
  │ CDF generation      │ Reproduce Figures 3-11                            │
  └─────────────────────┴───────────────────────────────────────────────────┘

  ---
  Whenever you're ready, we can deep-dive into any section and start the MATLAB
  implementation. Where would you like to begin?

✻ Churned for 1m 55s

❯ Let's deep dive into Section II first.                                    
  You will explain in as much detailed possible. For mathematical           
  explanation, use unicode mathematical notation so that it renders         
  properly on terminal.                                                     
  Try to follow this structure.                                             
  First give a high level explanation with easy and understandable terms.   
  Then, deep dive and explain in details and if possible give mathematical  
  examples.                                                                 
  You should provide your response in 4 chunks.                             
  1st chunk --> explain initial discussion on system model                  
  2nd chunk --> Uplink training                                             
  3rd chunk --> Downlink Payload data transmission                          
  4th chunk --> Uplink Payload data transmission                            
  ---------------------                                                     
  Do deep research on the web, IEEE site, different relevant blog sites and 
   articles available on web.                                               
  Double check and verify before providing your final response so that      
  there is no scope for error.                                              

● I'll do thorough research first, then give you the deep dive. Let me gather
  resources from the web and re-read the paper section carefully.

● 2 Agent agents finished (ctrl+o to expand)
   ├─ Research CF-mMIMO system model · 58 tool uses · 63.9k tokens
   │  ⎿  Done
   └─ Research MMSE estimation details · 57 tool uses · 49.0k tokens
      ⎿  Done

● Excellent. Now I have thorough research. Let me give you the full deep dive.

  ---
  SECTION II: Cell-Free Massive MIMO System Model — Complete Deep Dive

  ---
  CHUNK 1: System Architecture & Channel Model

  1.1 The High-Level Picture (Simple Terms)

  Imagine a big park (1 km × 1 km). Instead of placing one tall cell tower in
  the middle, you scatter 100 tiny lamp-post-mounted antennas (Access Points /
  APs) all over the park. Now 40 people (users) walk around with phones. Every 
  single AP talks to every single user at the same time, on the same frequency.
  There are no "cells", no boundaries, no "edge of coverage." A user standing
  anywhere is always near some APs.

  All these APs are connected by cables (backhaul) to a Central Processing Unit 
  (CPU) — a server room that coordinates everything. But here's the key
  constraint: the APs do NOT share their fast-changing channel measurements with
   each other. Each AP estimates channels on its own and does its own signal
  processing locally. Only the data symbols and slowly-changing power control
  coefficients travel over the backhaul.

  1.2 Formal System Setup

  The system has:

  M = number of Access Points (e.g., 100)
  K = number of users         (e.g., 40)

  Both APs and users have a single antenna each. All M APs simultaneously serve
  all K users on the same time-frequency resource. The operating regime is M ≫ K
   (many more APs than users), which is the hallmark of the Massive MIMO
  paradigm.

  1.3 TDD Protocol — The Three Phases

  The wireless channel changes over time and frequency. It stays approximately
  constant over a block called the coherence interval, of length:

  τ_c = (coherence time) × (coherence bandwidth)   [in samples]

  For example, with coherence time = 1 ms and coherence bandwidth = 200 kHz:

  τ_c = 200 samples

  Each coherence interval is split into three phases:

  ┌─────────────────────────────────────────────────────┐
  │              One Coherence Interval (τ_c)           │
  ├──────────────┬──────────────────┬───────────────────-┤
  │  Phase 1:    │   Phase 2:       │   Phase 3:         │
  │  Uplink      │   Downlink       │   Uplink           │
  │  Training    │   Data TX        │   Data TX          │
  │  (τ_cf)      │                  │                    │
  └──────────────┴──────────────────┴────────────────────┘

  Phase 1 — Uplink Training (τ_cf samples): Users send known pilot sequences to
  the APs. Each AP uses these to estimate the channel to every user. Because of
  TDD reciprocity (uplink channel = downlink channel), this one set of estimates
   works for both directions.

  Phase 2 — Downlink Data (remaining samples, shared with Phase 3): APs use
  their channel estimates to beamform data to users. Users do NOT need to
  estimate the downlink channel (thanks to channel hardening — explained later).

  Phase 3 — Uplink Data: Users transmit data. APs detect using their channel
  estimates.

  Why TDD and not FDD? In FDD, uplink and downlink use different frequencies, so
   the channels are different. Users would need to estimate the downlink channel
   and feed it back — a massive overhead with 100 APs. TDD exploits reciprocity:
   estimate once on the uplink, use for both.

  1.4 The Channel Model — Equation (1)

  The channel coefficient between the m-th AP and the k-th user is:

  g_mk = √β_mk · h_mk                                    ... (1)

  This is a product of two independent effects:

  (a) Large-scale fading: β_mk (deterministic, slowly changing)

  This captures path loss (signal weakens with distance) and shadow fading
  (random blockage by buildings/trees). It depends on:
  - The distance d_mk between AP m and user k
  - The random shadowing environment

  β_mk changes very slowly — constant for ~40 coherence intervals (seconds). It
  is assumed known at both the AP and the CPU (estimated from long-term
  averaging of received signal strength).

  Critical difference from collocated Massive MIMO: In collocated systems, all M
   antennas are at the same base station, so β_mk = β_k for all m (same
  distance). In Cell-Free, every AP-user pair has a different β_mk because the
  APs are spread out. This is what makes the analysis and power control
  fundamentally different.

  (b) Small-scale fading: h_mk (random, changes every coherence interval)

  h_mk ~ CN(0, 1)     (i.i.d. complex Gaussian, zero mean, unit variance)

  This is Rayleigh fading — modeling multipath propagation (signal bouncing off
  scatterers). Key properties:

  - Independent across all (m, k) pairs. Why? APs and users are far apart from
  each other, so the scattering environments are different.
  - Changes every coherence interval — must be re-estimated each time.
  - |h_mk|² ~ Exponential(1), so E{|h_mk|²} = 1.

  Numerical Example

  Suppose AP₃ is 200m away from User₅. The path loss gives β₃₅ = 10⁻⁹·⁵ (≈ −95
  dB). The small-scale fading in this coherence interval happens to be h₃₅ = 0.7
   + 0.4j. Then:

  g₃₅ = √(10⁻⁹·⁵) · (0.7 + 0.4j) ≈ 1.78×10⁻⁵ · (0.7 + 0.4j)

  Meanwhile, AP₇ is only 30m from User₅, so β₇₅ = 10⁻⁷ (≈ −70 dB), and:

  g₇₅ = √(10⁻⁷) · h₇₅ ≈ 3.16×10⁻⁴ · h₇₅

  AP₇'s channel is ~18× stronger than AP₃'s, simply because it's closer. This
  distance-dependent variation is the essence of the distributed architecture.

  1.5 Key Assumptions (Summarized)

  ┌──────────────────────────────────────┬──────────────────────────────────┐
  │              Assumption              │          Justification           │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Single antenna at each AP and user   │ Simplicity; multi-antenna is     │
  │                                      │ future work                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ h_mk ~ i.i.d. CN(0,1)                │ APs/users spread out → different │
  │                                      │  scatterers                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ β_mk known a priori                  │ Changes slowly, can be tracked   │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Perfect backhaul (infinite capacity, │ Idealized; practical constraints │
  │  no errors)                          │  are future work                 │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Channel reciprocity (uplink =        │ Requires TDD + hardware          │
  │ downlink)                            │ calibration                      │
  ├──────────────────────────────────────┼──────────────────────────────────┤
  │ Symbols q_k are i.i.d., independent  │ Standard assumption              │
  │ of channels/noise                    │                                  │
  └──────────────────────────────────────┴──────────────────────────────────┘

  1.6 Figure 1 — System Architecture

          ┌─────────┐
          │   CPU   │  ← Central Processing Unit
          └────┬────┘
               │ Backhaul (payload data + power control coefficients)
       ┌───────┼───────┬───────────┐
       │       │       │           │
     ┌─┴─┐  ┌─┴─┐  ┌──┴──┐   ┌──┴──┐
     │AP₁│  │AP₂│  │AP_m │   │AP_M │    ← M single-antenna APs
     └─┬─┘  └─┬─┘  └──┬──┘   └──┬──┘
       │╲      │╲      │╲        │╲       g_mk = channel coefficient
       │  ╲    │  ╲    │  ╲      │  ╲
     ┌─┴─┐ ┌──┴──┐ ┌──┴──┐  ┌──┴──┐
     │UE₁│ │UE_k │ │UE_k'│  │UE_K │    ← K single-antenna users
     └───┘ └─────┘ └─────┘  └─────┘

  What travels over the backhaul:
  - Payload data symbols (encoded/decoded at CPU)
  - Power control coefficients (change on large-scale fading timescale)

  What does NOT travel over the backhaul:
  - Instantaneous channel estimates (stay local at each AP)
  - Raw received signals (processed locally)

  This is the key architectural choice that makes Cell-Free Massive MIMO
  scalable.

  ---
  CHUNK 2: Uplink Training — Channel Estimation & Pilot Contamination

  2.1 The High-Level Picture

  Before the APs can serve the users, they need to know the channels. So the
  users send known "pilot" signals. Each AP listens, and from these known
  signals, figures out the channel to each user. This is like shining a
  flashlight in a foggy room — from how the known light pattern arrives, you can
   infer the properties of the fog (the channel).

  The problem: with τ_cf pilot samples, you can only create τ_cf mutually
  orthogonal pilot sequences. If K > τ_cf, some users must share the same pilot.
   When two users share a pilot, the AP cannot tell their channels apart — this
  is pilot contamination, the fundamental bottleneck of Massive MIMO.

  2.2 Pilot Sequences

  Let φ_k ∈ ℂ^{τ_cf × 1} be the pilot sequence used by the k-th user, with:

  ‖φ_k‖² = 1     (unit norm, normalized)

  There exist exactly τ_cf mutually orthogonal pilot sequences. If τ_cf ≥ K,
  each user gets a unique orthogonal pilot (φ_k^H φ_i = 0 for k ≠ i). If τ_cf <
  K (the typical case), some users must reuse pilots:

  φ_k^H φ_i = { 1   if users k and i share the same pilot
               { 0   otherwise

  2.3 Received Pilot Signal at AP m — Equation (2)

  During uplink training, all K users simultaneously transmit their pilot
  sequences. The received τ_cf × 1 vector at the m-th AP is:

                     K
  y_{p,m} = √(τ_cf · ρ_cf) · Σ  g_mk · φ_k^H  +  w_{p,m}          ... (2)
                    k=1

  where:
  - ρ_cf = normalized SNR of each pilot symbol (= pilot power / noise power)
  - g_mk = channel coefficient (what we want to estimate)
  - φ_k^H = Hermitian (conjugate transpose) of user k's pilot — a 1 × τ_cf row
  vector
  - w_{p,m} ~ CN(0, I_{τ_cf}) = additive noise at AP m (each element is i.i.d.
  CN(0,1))

  Dimensions check: g_mk is scalar, φ_k^H is 1 × τ_cf, so g_mk · φ_k^H is 1 ×
  τ_cf. We're summing K such terms, getting a 1 × τ_cf vector. With the noise,
  y_{p,m} is also τ_cf × 1 (taking transpose appropriately).

  Physical meaning: Each row of y_{p,m} is one time sample at AP m. The AP hears
   a superposition of all K users' pilots, each scaled by their respective
  channel.

  2.4 Projection onto Pilot of User k — Equation (3)

  To extract information about g_mk, the AP projects the received signal onto
  user k's pilot φ_k:

  ŷ_{p,mk} = φ_k^H · y_{p,m}

  Substituting Eq. (2):

                                        K
  ŷ_{p,mk} = √(τ_cf · ρ_cf) · g_mk + √(τ_cf · ρ_cf) · Σ   g_mk' · φ_k'^H · φ_k
  +  φ_k^H · w_{p,m}
                                       k'≠k

            = √(τ_cf · ρ_cf) · g_mk  +  √(τ_cf · ρ_cf) · Σ   g_mk' · φ_k'^H ·
  φ_k   +  w̃_{p,mk}
                                                           k'≠k
                     ... (3)

  where w̃_{p,mk} = φ_k^H · w_{p,m} ~ CN(0, 1) (the noise after projection is
  still CN(0,1) because ‖φ_k‖² = 1).

  Let's break this down into three terms:

  ┌──────────────────┬─────────────────────────────┬────────────────────────┐
  │       Term       │         Expression          │        Meaning         │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Desired          │ √(τ_cf · ρ_cf) · g_mk       │ The channel we want    │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Pilot            │ √(τ_cf · ρ_cf) · Σ_{k'≠k}   │ Interference from      │
  │ contamination    │ g_mk' · φ_k'^H φ_k          │ co-pilot users         │
  ├──────────────────┼─────────────────────────────┼────────────────────────┤
  │ Noise            │ w̃_{p,mk}                    │ Filtered noise         │
  └──────────────────┴─────────────────────────────┴────────────────────────┘

  When φ_k'^H φ_k = 0 (orthogonal pilots): the second term vanishes, and
  ŷ_{p,mk} is a clean observation of g_mk plus noise.

  When φ_k'^H φ_k ≠ 0 (shared pilots): the AP sees g_mk mixed with g_mk' — it
  cannot tell them apart. This is pilot contamination.

  2.5 MMSE Channel Estimation — Equation (4)

  Now the AP must estimate g_mk from the observation ŷ_{p,mk}. Since everything
  is Gaussian, the Minimum Mean Square Error (MMSE) estimator is optimal and has
   a simple linear form.

  MMSE estimation theory recap: For jointly Gaussian x and y with zero means:

  x̂_MMSE = (C_xy / C_yy) · y

  where C_xy = E{x·y*} (cross-covariance) and C_yy = E{|y|²} (auto-covariance).

  Applying to our problem:

  The unknown is x = g_mk ~ CN(0, β_mk), the observation is y = ŷ_{p,mk}.

  Step 1: Cross-covariance C_{g,y}

  Since g_mk is independent of g_mk' (k' ≠ k) and of w̃_{p,mk}:

  C_{g,y} = E{g_mk · ŷ_{p,mk}*} = √(τ_cf · ρ_cf) · E{|g_mk|²} = √(τ_cf · ρ_cf) ·
   β_mk

  Step 2: Auto-covariance C_{y,y}

  C_{y,y} = E{|ŷ_{p,mk}|²}

          = τ_cf · ρ_cf · E{|g_mk|²}  +  τ_cf · ρ_cf · Σ_{k'≠k} E{|g_mk'|²} ·
  |φ_k'^H φ_k|²  +  1

          = τ_cf · ρ_cf · β_mk  +  τ_cf · ρ_cf · Σ_{k'≠k} β_mk' · |φ_k'^H φ_k|²
   +  1

          = τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|²  +  1

  Step 3: The MMSE estimate

  ĝ_mk = c_mk · ŷ_{p,mk}
  ... (4)

  where the MMSE coefficient is:

                          √(τ_cf · ρ_cf) · β_mk
  c_mk = ─────────────────────────────────────────────────────
          τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|²  +  1

  2.6 Numerical Example — MMSE Estimation

  Let's work through a concrete example to make this tangible.

  Setup: M = 3 APs, K = 3 users, τ_cf = 2 (only 2 orthogonal pilots for 3
  users).

  Pilot assignment: Users 1 and 3 share pilot φ₁, User 2 uses pilot φ₂. So:
  - φ₁^H φ₃ = 1 (same pilot)
  - φ₁^H φ₂ = 0 (orthogonal)

  Large-scale fading at AP 1:
  - β₁₁ = 10⁻⁸ (user 1 is 100m away)
  - β₁₂ = 10⁻⁹ (user 2 is 300m away)
  - β₁₃ = 10⁻⁷ (user 3 is 30m away)

  Let τ_cf · ρ_cf = 10⁸ (training SNR parameter).

  Computing c₁₁ (MMSE coeff for AP 1, User 1):

                       √(10⁸) · 10⁻⁸
  c₁₁ = ──────────────────────────────────────────
         10⁸ · (β₁₁·|φ₁^Hφ₁|² + β₁₂·|φ₂^Hφ₁|² + β₁₃·|φ₃^Hφ₁|²) + 1

                       10⁴ · 10⁻⁸
       = ──────────────────────────────────────────
         10⁸ · (10⁻⁸·1 + 10⁻⁹·0 + 10⁻⁷·1) + 1

                  10⁻⁴
       = ────────────────────
         10⁸·10⁻⁸ + 10⁸·10⁻⁷ + 1

                  10⁻⁴
       = ──────────────────
           1 + 10 + 1

                10⁻⁴
       = ─────────── ≈ 8.33 × 10⁻⁶
             12

  Notice the pilot contamination effect: The denominator includes 10⁸ · β₁₃ = 10
   (from user 3, who shares the same pilot). This 10× inflates the denominator,
  reducing the estimation quality for user 1. User 3 is closer to AP 1 and
  contaminates user 1's estimate.

  If pilots were orthogonal (no contamination from user 3):

  c₁₁ (no contamination) = 10⁻⁴ / (1 + 1) = 5 × 10⁻⁵

  That's 6× larger, meaning a much better estimate without pilot contamination.

  2.7 Properties of the MMSE Estimate

  The MMSE estimation has a beautiful decomposition:

  g_mk = ĝ_mk + ε_mk      (true channel = estimate + error)

  where:
  - ĝ_mk ~ CN(0, γ_mk) is the estimate
  - ε_mk ~ CN(0, β_mk − γ_mk) is the estimation error
  - ĝ_mk and ε_mk are statistically independent (fundamental property of MMSE
  for Gaussians: uncorrelated Gaussian ⟹ independent)

  The estimate variance γ_mk (also written as E{|ĝ_mk|²}) is:

                      τ_cf · ρ_cf · β_mk²
  γ_mk = ──────────────────────────────────────────────            ... (8)
          τ_cf · ρ_cf · Σ_{k'=1}^{K} β_mk' · |φ_k'^H φ_k|² + 1

  Note: γ_mk = √(τ_cf · ρ_cf) · β_mk · c_mk. This γ_mk appears everywhere in the
   rate expressions later.

  2.8 Remark 1 & 2 — Key Insights

  Remark 1 (Pilot contamination): If τ_cf ≥ K, we can make all pilots orthogonal
   → no pilot contamination → the estimate ĝ_mk is independent of g_mk' for k' ≠
   k. But typically τ_cf < K (limited coherence interval), so contamination is
  unavoidable.

  Remark 2 (Decentralized estimation): Each AP estimates channels independently.
   AP m uses only its own received signal y_{p,m}. No coordination, no CSI
  sharing. This is essential for scalability.

  ---
  CHUNK 3: Downlink Payload Data Transmission

  3.1 The High-Level Picture

  After estimating channels, the APs transmit data to all K users. Each AP knows
   its own channel estimates and treats them as if they were the true channels.
  It uses conjugate beamforming — multiply each user's data symbol by the
  conjugate of the channel estimate. This is the simplest possible precoding
  scheme, and it works remarkably well in the Massive MIMO regime.

  The magic: when you sum up the signals from all M APs at a user, the desired
  signal adds up coherently (in phase), while interference from other users adds
   up incoherently (random phases, partially cancels). As M grows, the desired
  signal grows as M while interference grows as √M — the ratio improves.

  3.2 Conjugate Beamforming — Equation (5)

  The transmitted signal from the m-th AP is:

                K
  x_m = √ρ_df · Σ  √η_mk · ĝ*_mk · q_k                          ... (5)
               k=1

  where:
  - ρ_df = normalized downlink SNR (= downlink power / noise power)
  - η_mk = power control coefficient (how much power AP m allocates to user k)
  - ĝ_mk* = complex conjugate of the channel estimate (the beamforming weight)
  - q_k = data symbol for user k, with E{|q_k|²} = 1

  Why the conjugate ĝ_mk?* Think of it physically:

  The channel g_mk has some phase rotation θ_mk. The signal arriving at user k
  from AP m gets multiplied by g_mk = |g_mk|·e^{jθ_mk}. If we pre-multiply by
  ĝ*_mk ≈ |g_mk|·e^{−jθ_mk}, the product g_mk · ĝ*_mk ≈ |g_mk|² is real and 
  positive. The signals from all M APs arrive at user k approximately in phase
  and add up constructively. This is the phase alignment principle.

  3.3 Per-AP Power Constraint — Equations (6)–(8)

  Unlike collocated Massive MIMO (one total power budget for all antennas),
  Cell-Free has a separate power constraint at each AP:

  E{|x_m|²} ≤ ρ_df     for all m = 1, ..., M                      ... (6)

  Substituting Eq. (5) and using the fact that q_k's are independent with unit
  power:

                  K
  E{|x_m|²} = ρ_df · Σ  η_mk · E{|ĝ_mk|²}
                 k=1
                  K
             = ρ_df · Σ  η_mk · γ_mk
                 k=1

  So the power constraint becomes:

  K
  Σ  η_mk · γ_mk ≤ 1     for all m = 1, ..., M                    ... (7)
  k=1

  where γ_mk is defined as:

  γ_mk ≜ E{|ĝ_mk|²} = τ_cf · ρ_cf · β_mk · c_mk                 ... (8)

  Physical meaning of Eq. (7): Each AP m has a total power budget of 1
  (normalized). The fraction η_mk · γ_mk is the average power AP m spends on
  serving user k. The sum over all users must not exceed the budget.

  3.4 Received Signal at User k — Equation (9)

  The k-th user receives a superposition of signals from all M APs:

               M
  r_{d,k} =   Σ   g_mk · x_m  +  w_{d,k}
              m=1

             M    K
        = √ρ_df · Σ    Σ  √η_mk' · g_mk · ĝ*_mk' · q_k'  +  w_{d,k}     ... (9)
            m=1  k'=1

  where w_{d,k} ~ CN(0, 1) is additive noise at user k.

  Splitting into desired signal + interference:

                    M                                M    K
  r_{d,k} = √ρ_df · Σ  √η_mk · g_mk · ĝ*_mk · q_k + √ρ_df · Σ    Σ   √η_mk' ·
  g_mk · ĝ*_mk' · q_k' + w_{d,k}
                   m=1                               m=1  k'≠k
                └───────────── DS_k ─────────────┘       └──────────────── MUI_k
   ─────────────────┘

  where DS_k = desired signal, MUI_k = multi-user interference.

  3.5 Channel Hardening — Why No Downlink Pilots Are Needed

  This is one of the most profound aspects of Massive MIMO. Let's understand it
  step by step.

  The effective channel gain that user k sees is:

                M
  a_k  ≜  Σ  √η_mk · g_mk · ĝ*_mk
              m=1

  This is a sum of M random terms. By the law of large numbers, as M → ∞:

  a_k  →  E{a_k} = Σ_{m=1}^{M} √η_mk · E{g_mk · ĝ*_mk} = Σ_{m=1}^{M} √η_mk ·
  γ_mk

  The random channel gain concentrates around a deterministic constant. The
  channel "hardens" — the randomness disappears.

  Why this matters for downlink: In a normal system (say, a single AP serving a
  user), the user must estimate the channel to decode data. Here, the effective
  channel is approximately a known constant — the user just uses its expected
  value. No downlink pilots needed. This saves precious training overhead.

  Figure 2 of the paper confirms this. It compares:
  - Rate assuming user knows only statistics (Eq. 24)
  - Rate assuming a genie gives user the exact channel (Eq. 26)

  The gap is tiny, proving channel hardening works.

  Numerical intuition: If M = 100, and each term g_mk · ĝ*_mk has mean γ_mk and
  some variance, the sum of 100 such terms has variance/mean² that shrinks as
  1/M_eff (where M_eff is the effective number of contributing APs). Even with
  M_eff ≈ 15–20 (due to nearby APs dominating), the hardening is sufficient.

  3.6 What Gets Sent Over the Backhaul

  Let's be precise about the information flow:

                  CPU
                 ╱    ╲
       data symbols    power control coefficients
       q₁, q₂, ..., qK    η_mk (change slowly)
                │               │
                ▼               ▼
              AP m computes: x_m = √ρ_df · Σ_k √η_mk · ĝ*_mk · q_k
                                            ↑
                                     local channel estimate
                                     (never leaves AP m)

  The CPU sends each AP the same data symbols q₁,...,q_K plus the power control
  coefficients η_mk. The AP does all beamforming locally. This is what keeps the
   backhaul requirements manageable.

  ---
  CHUNK 4: Uplink Payload Data Transmission

  4.1 The High-Level Picture

  In the uplink, roles reverse. All K users transmit their data simultaneously
  (same time, same frequency) to all M APs. Each AP receives a cocktail mixture
  of all users' signals. The AP applies matched filtering — multiplying by the
  conjugate of its channel estimate — to extract each user's signal. These
  locally-filtered signals are forwarded to the CPU, which combines them for
  final detection.

  Think of it as 40 people talking simultaneously in a room with 100
  microphones. Each microphone tries to isolate each speaker using what it knows
   about the acoustics (channel estimates). The central server then combines all
   100 microphones' outputs for each speaker to get a clean signal.

  4.2 Uplink Signal Model — Equation (10)

  The k-th user transmits √(η_k) · q_k, where η_k ∈ [0, 1] is its uplink power
  control coefficient and q_k (E{|q_k|²} = 1) is the data symbol. The received
  signal at AP m is:

                       K
  y_{u,m} = √ρ_uf ·  Σ  g_mk · √η_k · q_k  +  w_{u,m}              ... (10)
                     k=1

  where:
  - ρ_uf = normalized uplink SNR
  - w_{u,m} ~ CN(0, 1) = additive noise at AP m

  Key difference from downlink: In the uplink, there are only K power control
  coefficients η_k (one per user), not M×K as in the downlink. This makes uplink
   power control much simpler.

  4.3 Matched Filtering at Each AP

  To detect user k's symbol, AP m multiplies the received signal by the
  conjugate of its channel estimate:

  r̂_{m,k} = ĝ*_mk · y_{u,m}

  This is done locally at AP m using only its own channel estimate. The result
  r̂_{m,k} is a scalar — one number representing AP m's "vote" on what user k
  transmitted.

  4.4 Combining at the CPU — Equation (11)

  AP m sends r̂_{m,k} = ĝ*mk · y{u,m} to the CPU via the backhaul. The CPU
  combines all M APs' contributions:

                M
  r_{u,k} =   Σ   ĝ*_mk · y_{u,m}
              m=1

            K    M                              M
      = √ρ_uf · Σ   √η_k' · ( Σ  ĝ*_mk · g_mk') · q_k'  +  Σ  ĝ*_mk · w_{u,m}
    ... (11)
           k'=1         m=1                           m=1

  Decomposing into signal and interference:

                         M                       K           M
      M
  r_{u,k} = √ρ_uf · √η_k · Σ  ĝ*_mk · g_mk · q_k  +  √ρ_uf · Σ   √η_k' · Σ
  ĝ*_mk · g_mk' · q_k' + Σ  ĝ*_mk · w_{u,m}
                        m=1                          k'≠k        m=1
        m=1
             └────────── desired signal ──────────┘     └────────── inter-user
  interference ──────────┘   └── noise ──┘

  4.5 Why Matched Filtering Works — Favorable Propagation

  The key inner product is:

           M
  a_kk' = Σ  ĝ*_mk · g_mk'
          m=1

  For the desired user (k' = k):

           M                    M
  a_kk = Σ  ĝ*_mk · g_mk  =  Σ  (|ĝ_mk|² + ĝ*_mk · ε_mk)
         m=1                  m=1

  Using the decomposition g_mk = ĝ_mk + ε_mk (estimate + error), and since ĝ_mk
  and ε_mk are independent:

  E{a_kk} = Σ_{m=1}^{M} E{|ĝ_mk|²} = Σ_{m=1}^{M} γ_mk

  As M grows, by the law of large numbers: a_kk / M → (1/M) · Σ_m γ_mk
  (deterministic).

  For interfering users (k' ≠ k) with orthogonal pilots:

  E{a_kk'} = Σ_{m=1}^{M} E{ĝ*_mk · g_mk'} = 0     (since ĝ_mk and g_mk' are
  independent)

  And by the law of large numbers: a_kk' / M → 0. This is favorable propagation:
   the channels of different users become asymptotically orthogonal.

  For interfering users (k' ≠ k) sharing the same pilot as k:

  E{a_kk'} = Σ_{m=1}^{M} E{ĝ*_mk · g_mk'} ≠ 0     (because ĝ_mk contains g_mk'
  contamination)

  This non-zero term persists even as M → ∞. This is the pilot contamination 
  bottleneck — it creates a ceiling on performance.

  4.6 What Travels Over the Backhaul (Uplink)

             AP m
              │
              │  computes: r̂_{m,k} = ĝ*_mk · y_{u,m}  for each k = 1,...,K
              │  (K scalar values per AP)
              │
              ▼
             CPU
              │
              │  combines: r_{u,k} = Σ_{m=1}^{M} r̂_{m,k}
              │  then detects q_k from r_{u,k}

  Each AP sends K complex scalars to the CPU (one per user). Total backhaul
  load: M × K complex numbers per coherence interval. Crucially, the AP sends
  the filtered signal, not the raw received signal — this is much more
  efficient.

  4.7 Comparison: Downlink vs. Uplink Processing

  ┌──────────────────┬─────────────────────────┬───────────────────────────┐
  │      Aspect      │        Downlink         │          Uplink           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Processing at AP │ Beamforming: multiply   │ Matched filter: multiply  │
  │                  │ q_k by ĝ*_mk            │ y_{u,m} by ĝ*_mk          │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ What AP needs    │ Channel estimates +     │ Channel estimates +       │
  │                  │ data symbols            │ received signal           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Backhaul content │ CPU → AP: data symbols  │ AP → CPU: filtered        │
  │                  │ q_k                     │ signals ĝ*mk · y{u,m}     │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Power control    │ η_mk (M × K variables)  │ η_k (K variables)         │
  │ variables        │                         │                           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Power constraint │ Per-AP: Σ_k η_mk · γ_mk │ Per-user: 0 ≤ η_k ≤ 1     │
  │                  │  ≤ 1                    │                           │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Channel          │ User uses E{channel}    │ CPU uses E{channel} for   │
  │ hardening        │ for decoding            │ decoding                  │
  ├──────────────────┼─────────────────────────┼───────────────────────────┤
  │ Combining        │ Happens naturally over  │ Done at CPU after         │
  │                  │ the air                 │ backhaul                  │
  └──────────────────┴─────────────────────────┴───────────────────────────┘

  4.8 Summary of the Complete System Flow

  Timeline within one coherence interval (τ_c = 200 samples):

    ◄──── τ_cf = 20 ────►◄──────── ~90 ────────►◄──────── ~90 ────────►
    ┌────────────────────┬────────────────────────┬────────────────────────┐
    │   UPLINK TRAINING  │   DOWNLINK DATA        │   UPLINK DATA          │
    │                    │                        │                        │
    │ Users → APs:       │ APs → Users:           │ Users → APs:           │
    │ Send pilots φ_k    │ Conjugate beamforming   │ Send data √η_k · q_k  │
    │                    │ x_m = √ρ · Σ √η_mk    │                        │
    │ APs estimate:      │      · ĝ*_mk · q_k    │ APs apply MF:          │
    │ ĝ_mk = c_mk·ŷ_mk │                        │ r̂_mk = ĝ*_mk · y_um  │
    │                    │ Users decode using      │                        │
    │                    │ E{effective channel}    │ CPU combines:          │
    │                    │ (no DL pilots needed)   │ r_uk = Σ_m r̂_mk      │
    └────────────────────┴────────────────────────┴────────────────────────┘

  ---
  This completes the deep dive into Section II. The foundation is now solid —
  the channel model, estimation, and beamforming/filtering are the building
  blocks for everything that follows (rate derivations in Section III, power
  control in Section IV). Shall we move to Section III next?

✻ Brewed for 13m 18s

❯ /export understanding_paper_sec2.txt 
  ⎿  Conversation exported to: understanding_paper_sec2.txt

❯ Yes, now move to the next part. Section 3. 

● Let me do thorough research on Section III first, then provide the deep dive.

● 2 Agent agents finished (ctrl+o to expand)
   ├─ Research achievable rate bounds · 66 tool uses · 82.8k tokens
   │  ⎿  Done
   └─ Research SINR derivation details · 48 tool uses · 76.1k tokens
      ⎿  Done

● Now let me give you the complete deep dive into Section III.

  ---
  SECTION III: Performance Analysis — Complete Deep Dive

  ---
  CHUNK 1: Large-M Analysis (Section III-A) — What Happens as M → ∞

  1.1 The High-Level Picture (Simple Terms)

  Imagine you have 100 APs and 40 users. Now imagine increasing the number of
  APs to 1,000... 10,000... infinity. What happens? Three beautiful things:

  1. Noise disappears — with more APs listening, the collective SNR goes to
  infinity.
  2. Non-coherent interference vanishes — signals from other users (who use
  different pilots) cancel out through the law of large numbers.
  3. Small-scale fading averages out — the random channel fluctuations become
  deterministic.

  The only thing that survives is pilot contamination — interference from users
  who share the exact same pilot sequence. This is the fundamental ceiling of
  Massive MIMO.

  1.2 The Mathematical Tool: Tchebyshev's Theorem

  The paper uses a specific form of the Weak Law of Large Numbers (called
  Tchebyshev's theorem in the paper):

  Theorem: Let X₁, X₂, ..., Xₙ be independent random variables (not necessarily
  identically distributed) with E{Xᵢ} = μᵢ and Var{Xᵢ} ≤ c < ∞ for all i. Then:

    1                  1
   ─── (X₁+X₂+...+Xₙ) − ─── (μ₁+μ₂+...+μₙ)  ──→  0   in probability
    n                    n                        n→∞

  Why this matters: In Cell-Free MIMO, sums like Σ_m g_mk · ĝ*_mk' involve M
  independent terms (one per AP). As M → ∞, these sums converge to their
  expected values. The randomness vanishes.

  Key subtlety: The Xᵢ's need NOT be identically distributed — perfect for
  Cell-Free where each AP has a different β_mk. The only requirement is bounded
  variance, which holds because |g_mk · ĝ*_mk'|² has bounded variance for any
  finite β_mk.

  1.3 Downlink Signal Decomposition for Large-M

  Recall from Section II that the received signal at user k is:

                      M                                    M    K
  r_{d,k} = √ρ_df ·  Σ  √η_mk · g_mk · ĝ*_mk · q_k  +  √ρ_df · Σ    Σ   √η_mk' ·
   g_mk · ĝ*_mk' · q_k'  +  w_{d,k}
                     m=1                                  m=1  k'≠k
                    └──────────── DS_k ────────────┘       └────────────────
  MUI_k ────────────────┘

  Now let's analyze the inner products as M → ∞.

  1.4 Expanding the Inner Product Using Eq. (4)

  The key quantity is Σ_m √η_mk · g_mk · ĝ*mk'. Substituting the MMSE estimate 
  ĝ_mk' = c_mk' · ŷ{p,mk'} and expanding:

   M                          M                    ⎡                K
                   ⎤
   Σ  √η_mk · g_mk · ĝ*_mk' = Σ  √η_mk · c_mk' · g_mk · ⎢ √(τ_cf·ρ_cf) · Σ
  g*_mk'' · φ_k''^H·φ_k'  +  w̃*_{p,mk'} ⎥
  m=1                        m=1                   ⎣               k''=1
                   ⎦

  Expanding the sum over k'':

           M
  = τ_cf·ρ_cf · Σ  √η_mk · c_mk' · |g_mk|² · φ_k^H·φ_k'          ← term with
  k''=k (desired user)
          m=1

           K     M
  + τ_cf·ρ_cf · Σ    Σ  √η_mk · c_mk' · g_mk · g*_mk'' · φ_k''^H·φ_k'    ← terms
   with k''≠k (other users)
          k''≠k m=1

      M
  +   Σ  √η_mk · c_mk' · g_mk · w̃*_{p,mk'}                        ← noise term
     m=1

  1.5 Applying Tchebyshev's Theorem (Eq. 14)

  Now apply the law of large numbers to each term as M → ∞:

  Term 1 (k'' = k): Each summand √η_mk · c_mk' · |g_mk|² is independent across m
   (different APs).

   1    M                                           1    M
  ───   Σ  √η_mk · c_mk' · |g_mk|²  ──→  ───   Σ  √η_mk · c_mk' · β_mk     in
  probability
   M   m=1                              M→∞    M   m=1

  because E{|g_mk|²} = β_mk.

  Term 2 (k'' ≠ k, k'' ≠ k'): Each summand involves g_mk · g*_mk'' where m is
  the same AP. Since h_mk and h_mk'' are independent CN(0,1):

  E{g_mk · g*_mk''} = √(β_mk · β_mk'') · E{h_mk · h*_mk''} = 0

  By Tchebyshev: (1/M) Σ_m √η_mk · c_mk' · g_mk · g*_mk'' → 0.

  Term 3 (noise): Similarly, g_mk and w̃_{p,mk'} are independent, so the average
  tends to zero.

  1.6 The Surviving Signal as M → ∞ (Eqs. 15–18)

  Putting it all together, as M → ∞:

  Desired signal converges:

   1                         1    M
  ─── DS_k  ──→  τ_cf·ρ_cf·ρ_df · ─── Σ  √η_mk · c_mk · β_mk · q_k       ...
  (15)
   M          M→∞                M  m=1

  Using the fact that γ_mk = τ_cf · ρ_cf · β_mk · c_mk, this simplifies to:

   1                   1    M
  ─── DS_k  ──→  ρ_df · ─── Σ  √η_mk · γ_mk · q_k
   M          M→∞      M  m=1

  Multi-user interference converges:

   1                    1    M                                  K
  ─── MUI_k  ──→  τ_cf·ρ_cf·ρ_df · ─── Σ  √η_mk · c_mk · β_mk' · |φ_k'^H φ_k|² ·
   q_k'      ... (16)
   M           M→∞                 M  m=1                                k'≠k

  The only interference that survives comes from users k' where φ_k'^H φ_k ≠ 0
  (i.e., users sharing the same pilot as user k). If all pilots are orthogonal:

   1
  ─── MUI_k  ──→  0        (all interference vanishes!)           ... (18)
   M          M→∞

  1.7 Physical Interpretation

     As M → ∞:

     ┌─────────────────────────────────────────────────────────────┐
     │  ✓ Noise → 0              (drowned out by M-fold gain)     │
     │  ✓ Small-scale fading → 0 (averaged over M APs)            │
     │  ✓ Non-coherent MUI → 0   (random phases cancel)           │
     │  ✗ Pilot contamination → REMAINS (same pilot = same phase) │
     └─────────────────────────────────────────────────────────────┘

  Why pilot contamination survives: When users k and k' share the same pilot,
  the channel estimate ĝ_mk contains information about g_mk' (not just g_mk).
  The beamformer ĝ*_mk therefore coherently combines g_mk' with the same phase
  alignment as g_mk. This coherent alignment persists no matter how large M is —
   it's not randomness that averages out, it's systematic bias in the estimate.

  1.8 Numerical Illustration

  Setup: M APs, 2 users sharing the same pilot. User 1 is desired, User 2 is the
   contaminator.

  ┌───────────────────────────┬────────────┬──────┬───────┬────────┐
  │         Quantity          │  Scaling   │ M=10 │ M=100 │ M=1000 │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Desired signal            │ DS_k       │      │ O(M)  │ ~10    │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Pilot contamination       │ MUI_k      │      │ O(M)  │ ~10    │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Non-coherent interference │ O(√M)      │ ~3.2 │ ~10   │ ~31.6  │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ Noise                     │ O(1)       │ ~1   │ ~1    │ ~1     │
  ├───────────────────────────┼────────────┼──────┼───────┼────────┤
  │ SINR                      │ → constant │ ~3   │ ~8    │ ~9.5   │
  └───────────────────────────┴────────────┴──────┴───────┴────────┘

  The SINR saturates because both desired signal and pilot contamination grow at
   the same rate O(M). The ratio approaches a finite ceiling determined by
  β_mk/β_mk'.

  ---
  CHUNK 2: The Use-and-Then-Forget (UatF) Bounding Technique

  2.1 The High-Level Picture

  For finite M, we can't just let M → ∞ and ignore interference. We need an
  exact, closed-form rate expression valid for any M and K. The problem: the
  user doesn't know the instantaneous effective channel, only its statistics.
  How do we bound the capacity?

  The Use-and-Then-Forget technique (from Medard 2000, Hassibi & Hochwald 2003)
  works in three steps:
  1. Use the channel estimate to design the beamformer (conjugate beamforming)
  2. Forget the channel estimate at the decoder — treat the effective channel as
   its mean value
  3. Treat everything else as worst-case Gaussian noise → capacity lower bound

  2.2 Signal Decomposition (Eq. 19)

  The downlink received signal at user k (Eq. 9) is rewritten as:

                                             K
  r_{d,k} = DS_k · q_k  +  BU_k · q_k  +   Σ   UI_{kk'} · q_k'  +  w_{d,k}
   ... (19)
                                            k'≠k

  where the three key terms are defined as:

                M
  DS_k  ≜  √ρ_df · E{ Σ  √η_mk · g_mk · ĝ*_mk }                    ... (20)
               m=1

                M                        M
  BU_k  ≜  √ρ_df · [ Σ  √η_mk · g_mk · ĝ*_mk  −  E{ Σ  √η_mk · g_mk · ĝ*_mk } ]
     ... (21)
               m=1                      m=1

                  M
  UI_{kk'} ≜ √ρ_df · Σ  √η_mk' · g_mk · ĝ*_mk'                     ... (22)
                 m=1

  DS_k (Desired Signal strength) — a deterministic scalar (the mean of the
  effective channel gain). This is what the user knows.

  BU_k (Beamforming Uncertainty) — the zero-mean random deviation of the
  effective channel from its mean. The user does not know this.

  UI_{kk'} (User Interference) — interference caused by the k'-th user. The user
   does not know this either.

  2.3 Why the Decomposition Works — Uncorrelated Terms

  The beauty is that DS_k · q_k is uncorrelated with each of the remaining
  terms:

  DS_k · q_k is uncorrelated with BU_k · q_k:

  E{(DS_k · q_k) · (BU_k · q_k)*} = E{DS_k · BU_k} · E{|q_k|²}
                                    = DS_k · E{BU_k} · 1
                                    = DS_k · 0  =  0      ✓

  (because BU_k has zero mean by construction)

  DS_k · q_k is uncorrelated with UI_{kk'} · q_k':

  E{(DS_k · q_k) · (UI_{kk'} · q_k')*} = DS_k · E{UI_{kk'}} · E{q_k · q*_k'}
                                         = DS_k · E{UI_{kk'}} · 0  =  0    ✓

  (because q_k and q_k' are independent for k ≠ k')

  2.4 The Worst-Case Noise Argument

  Since the signal DS_k · q_k is uncorrelated with the "effective noise" (BU_k ·
   q_k + Σ UI_{kk'} · q_k' + w_{d,k}), we can apply the information-theoretic 
  worst-case noise theorem:

  Theorem (Medard, 2000): For a channel Y = aX + N where a is a known constant 
  and N is uncorrelated with X, the mutual information I(X; Y) is minimized when
   N is Gaussian (for a given variance of N).

  Why Gaussian is worst-case: Gaussian noise maximizes entropy h(N) for a given
  variance. Since I(X; Y) = h(Y) - h(Y|X) = h(Y) - h(N), maximizing h(N)
  minimizes I(X; Y).

  Therefore, by assuming the effective noise is Gaussian, we get a lower bound
  on capacity:

  R_{d,k} ≥ log₂(1 + SINR_k)

  This is a rigorously achievable rate — any practical coding scheme can achieve
   at least this rate.

  2.5 The SINR Expression (Eq. 23)

                            |DS_k|²
  SINR_{d,k} = ────────────────────────────────────────────         ... (23)
                                  K
                E{|BU_k|²}  +   Σ   E{|UI_{kk'}|²}  +  1
                               k'≠k

  Now the task is to compute each term in closed form. That's Theorem 1.

  2.6 Why This Bound is Tight

  The gap between this lower bound and the true capacity depends on channel 
  hardening:

  - If the effective channel a_k = Σ_m √η_mk · g_mk · ĝ*_mk concentrates tightly
   around E{a_k}, then BU_k is small → the denominator is dominated by UI +
  noise → the bound is tight.
  - Figure 2 of the paper confirms: the gap between the statistics-only rate
  (Eq. 24) and the genie-aided rate (Eq. 26) is negligible for M ≥ 50.

  ---
  CHUNK 3: Theorem 1 — Achievable Downlink Rate (Eq. 24)

  3.1 Statement of Theorem 1

  Theorem 1: The achievable downlink rate for the k-th user in Cell-Free Massive
   MIMO with conjugate beamforming, for any finite M and K, is:

                                              ⎛
                    ⎞
                                              ⎜              ρ_df · (Σ_m √η_mk ·
   γ_mk)²           ⎟
  R^cf_{d,k} = log₂ ⎜ 1 +
  ──────────────────────────────────────────────────────────── ⎟    ... (24)
                                              ⎜       K    ⎛  M
      ⎞²    K   M                        ⎟
                                              ⎜  ρ_df·Σ    ⎜  Σ
  √η_mk'·γ_mk·|φ^H_k'φ_k|⎟  + ρ_df·Σ   Σ  η_mk'·γ_mk'·β_mk + 1 ⎟
                                              ⎜      k'≠k  ⎝ m=1
      ⎠       k'=1 m=1                   ⎟
                                              ⎝
                    ⎠

  Let me write this more cleanly. Define:

                M
  Numerator = ρ_df · ( Σ  √η_mk · γ_mk )²
               m=1

                   K     M                                          K    M
  Denominator = ρ_df · Σ   ( Σ  √η_mk' · γ_mk · |φ^H_k' φ_k|² )²  +  ρ_df · Σ
   Σ  η_mk' · γ_mk' · β_mk  +  1
                  k'≠k  m=1                                        k'=1 m=1

  3.2 Computing Each Term — The Proof (Appendix A)

  Let me derive each component step by step.

  Computing DS_k (Eq. 59)

  Using the MMSE decomposition g_mk = ĝ_mk + ε_mk where ĝ_mk ⊥ ε_mk:

           M
  DS_k = √ρ_df · Σ  √η_mk · E{g_mk · ĝ*_mk}
          m=1

           M
       = √ρ_df · Σ  √η_mk · E{(ĝ_mk + ε_mk) · ĝ*_mk}
          m=1

           M
       = √ρ_df · Σ  √η_mk · [E{|ĝ_mk|²} + E{ε_mk}·E{ĝ*_mk}]
          m=1                  ↑               ↑
                              = γ_mk           = 0 (independent, zero mean)

                  M
  ∴  DS_k = √ρ_df · Σ  √η_mk · γ_mk                                ... (59)
                 m=1

                         M
  ∴  |DS_k|² = ρ_df · ( Σ  √η_mk · γ_mk )²     ← this is the NUMERATOR
                        m=1

  Physical meaning: Each AP m contributes √η_mk · γ_mk to the coherent gain. The
   contributions are summed and then squared — this is the coherent beamforming 
  gain. As M grows, this term scales as O(M²).

  Computing E{|BU_k|²} (Eq. 60)

  The beamforming uncertainty variance is:

                   M
  E{|BU_k|²} = ρ_df · Σ  η_mk · [E{|g_mk · ĝ*_mk|²} − |E{g_mk · ĝ*_mk}|²]
                  m=1

  (The cross terms between different APs vanish because channels at different
  APs are independent.)

  We need the fourth moment E{|g_mk|² · |ĝ_mk|²}. Using g_mk = ĝ_mk + ε_mk:

  E{|g_mk|² · |ĝ_mk|²} = E{|ĝ_mk + ε_mk|² · |ĝ_mk|²}

                         = E{|ĝ_mk|⁴} + E{|ε_mk|² · |ĝ_mk|²}

                         (cross terms vanish: E{ε_mk · |ĝ_mk|² · ĝ*_mk} =
  E{ε_mk} · E{|ĝ_mk|² · ĝ*_mk} = 0)

  Now using the Gaussian fourth moment: for z ~ CN(0, σ²):

  E{|z|⁴} = 2σ⁴

  This is because |z|² ~ Exp(1/σ²), so E{|z|⁴} = E{(|z|²)²} = 2(σ²)² (second
  moment of exponential).

  Applying this:

  E{|ĝ_mk|⁴} = 2γ²_mk                          (since ĝ_mk ~ CN(0, γ_mk))

  E{|ε_mk|² · |ĝ_mk|²} = E{|ε_mk|²} · E{|ĝ_mk|²}    (independence)
                         = (β_mk − γ_mk) · γ_mk

  Therefore:

  E{|g_mk|² · |ĝ_mk|²} = 2γ²_mk + (β_mk − γ_mk) · γ_mk
                         = 2γ²_mk + β_mk · γ_mk − γ²_mk
                         = γ²_mk + β_mk · γ_mk
                         = γ_mk · (γ_mk + β_mk)

  Subtracting the squared mean γ²_mk:

  E{|g_mk · ĝ*_mk|²} − |E{g_mk · ĝ*_mk}|² = γ_mk · (γ_mk + β_mk) − γ²_mk = γ_mk
  · β_mk

  Final result:

                   M
  E{|BU_k|²} = ρ_df · Σ  η_mk · γ_mk · β_mk                       ... (60)
                  m=1

  Physical meaning: This is the variance of the effective channel gain. Each AP
  m contributes η_mk · γ_mk · β_mk — it's large when the estimate γ_mk is good
  AND the channel β_mk is strong. This term scales as O(M).

  Computing E{|UI_{kk'}|²} (Eqs. 61–68)

  This is the most intricate part. The interference from user k' to user k is:

                M
  UI_{kk'} = √ρ_df · Σ  √η_mk' · g_mk · ĝ*_mk'
               m=1

  Substituting ĝ_mk' = c_mk' · ŷ_{p,mk'} and expanding, we get two types of
  terms:

  Non-coherent part (from channel estimation noise and independent fading):

             M
  = ρ_df ·   Σ  η_mk' · c²_mk' · β_mk                (scales as O(M))
            m=1

  Coherent pilot contamination part (only when φ^H_k' φ_k ≠ 0):

                      M                                  ²
  = ρ_df · |φ^H_k' φ_k|² · ( Σ  √η_mk' · c_mk' · β_mk · φ^H_k φ_k )      (scales
   as O(M²))
                     m=1

  Using the relationship γ_mk = τ_cf · ρ_cf · β_mk · c_mk, the full expression
  simplifies to:

                                 M                                        ²
      M
  E{|UI_{kk'}|²} = ρ_df · |φ^H_k' φ_k|² · ( Σ  √η_mk' · γ_mk ·
  (β_mk'/β_mk)·(c_mk'/c_mk) )  +  ρ_df · Σ  η_mk' · γ_mk' · β_mk
                                m=1
     m=1

  When users share the same pilot (|φ^H_k' φ_k|² = 1), the first term gives the
  coherent interference that scales as M². When pilots are orthogonal (|φ^H_k'
  φ_k|² = 0), only the second (non-coherent) term survives.

  3.3 Putting It All Together — The Complete SINR

  The denominator of the SINR in Eq. (24) combines all interference and noise:

                       K      ⎛ M                              ⎞²      K    M
  Denom = ρ_df ·  Σ    ⎜ Σ  √η_mk' · γ_mk · |φ^H_k' φ_k|  ⎟  +  ρ_df · Σ    Σ
  η_mk' · γ_mk' · β_mk  +  1
                 k'≠k  ⎝m=1                              ⎠       k'=1 m=1
                 └────────── pilot contamination (coherent) ────────┘    └── BU
  + non-coherent UI ──┘     └noise┘

  ┌──────────────────────────────┬───────────────────────────┬──────────────┐
  │       Denominator term       │          Origin           │ Scaling with │
  │                              │                           │       M      │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ (Σ_m √η_mk' · γ_mk · |φ^H_k' │ Pilot contamination       │ O(M²)        │
  │  φ_k|)²                      │                           │              │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ Σ_m η_mk' · γ_mk' · β_mk     │ BU + non-coherent         │ O(M)         │
  │                              │ interference              │              │
  ├──────────────────────────────┼───────────────────────────┼──────────────┤
  │ 1                            │ Noise                     │ O(1)         │
  └──────────────────────────────┴───────────────────────────┴──────────────┘

  3.4 Numerical Example — Understanding the SINR

  Setup: M = 4 APs, K = 2 users, orthogonal pilots (|φ^H₁ φ₂|² = 0).

  ┌──────┬────────┬────────┬────────┬────────┐
  │ AP m │ β_{m1} │ β_{m2} │ γ_{m1} │ γ_{m2} │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 1    │ 0.5    │ 0.01   │ 0.4    │ 0.008  │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 2    │ 0.1    │ 0.3    │ 0.08   │ 0.24   │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 3    │ 0.2    │ 0.05   │ 0.16   │ 0.04   │
  ├──────┼────────┼────────┼────────┼────────┤
  │ 4    │ 0.02   │ 0.4    │ 0.016  │ 0.32   │
  └──────┴────────┴────────┴────────┴────────┘

  Equal power: η_mk = 1/(K · max_k γ_mk) for each AP m (satisfying constraint
  Eq. 7). For simplicity, let η_mk = 1 for all m,k and ρ_df = 10.

  Numerator (desired signal for user 1):

  ρ_df · (Σ_m √η_m1 · γ_m1)² = 10 · (0.4 + 0.08 + 0.16 + 0.016)² = 10 · (0.656)²
   = 10 · 0.430 = 4.30

  Denominator — coherent term: Zero (orthogonal pilots, |φ^H₂ φ₁|² = 0).

  Denominator — BU + non-coherent UI:

  BU (k'=1):  10 · Σ_m η_m1 · γ_m1 · β_m1 = 10 · (0.4·0.5 + 0.08·0.1 + 0.16·0.2
  + 0.016·0.02)
            = 10 · (0.2 + 0.008 + 0.032 + 0.00032) = 10 · 0.240 = 2.40

  UI (k'=2): 10 · Σ_m η_m2 · γ_m2 · β_m1 = 10 · (0.008·0.5 + 0.24·0.1 + 0.04·0.2
   + 0.32·0.02)
            = 10 · (0.004 + 0.024 + 0.008 + 0.0064) = 10 · 0.042 = 0.42

  SINR₁ = 4.30 / (0 + 2.40 + 0.42 + 1) = 4.30 / 3.82 = 1.126

  Rate₁ = log₂(1 + 1.126) = log₂(2.126) = 1.09 bits/s/Hz

  Now imagine M = 400 APs with similar statistics. The numerator scales as
  (400/4)² · 4.30 ≈ 43,000, the BU+UI scales as (400/4) · 2.82 ≈ 282, noise
  stays at 1. SINR ≈ 43,000/283 ≈ 152 → Rate ≈ 7.25 bits/s/Hz. The M²/M = M
  scaling gives huge gains!

  ---
  CHUNK 4: Theorem 2 (Uplink Rate), Remarks, and Figure 2

  4.1 Theorem 2 — Achievable Uplink Rate (Eq. 27)

  Theorem 2: The achievable uplink rate for the k-th user in Cell-Free Massive
  MIMO with matched filtering, for any M and K, is:

                                          ⎛
                   ⎞
                                          ⎜          ρ_uf · η_k · (Σ_m γ_mk)²
                   ⎟
  R^cf_{u,k} = log₂ ⎜ 1 +
  ──────────────────────────────────────────────────────── ⎟     ... (27)
                                          ⎜       K    ⎛ M
  ⎞²    K   M                       M      ⎟
                                          ⎜  ρ_uf·Σ  η_k'·⎜Σ  γ_mk·|φ^H_k'φ_k|⎟
   + ρ_uf·Σ  η_k'·Σ  γ_mk·β_mk' + Σ  γ_mk ⎟
                                          ⎜      k'≠k ⎝m=1                   ⎠
      k'=1  m=1              m=1     ⎟
                                          ⎝
                   ⎠

  4.2 Term-by-Term Comparison: Downlink vs. Uplink SINR

  ┌──────────────┬─────────────────────────────┬────────────────────────────┐
  │              │   Downlink SINR (Eq. 24)    │    Uplink SINR (Eq. 27)    │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Numerator    │ ρ_df · (Σ_m √η_mk · γ_mk)²  │ ρ_uf · η_k · (Σ_m γ_mk)²   │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Power ctrl   │ η_mk (M×K values)           │ η_k (K values)             │
  │ vars         │                             │                            │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Pilot        │ Σ_{k'≠k} (Σ_m √η_mk' · γ_mk │ Σ_{k'≠k} η_k' · (Σ_m γ_mk  │
  │ contam.      │  · |φ^H_k'φ_k|)²            │ · |φ^H_k'φ_k|)²            │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Non-coh.     │ Σ_{k'} Σ_m η_mk' · γ_mk' ·  │ Σ_{k'} η_k' · Σ_m γ_mk ·   │
  │ interf.      │ β_mk                        │ β_mk'                      │
  ├──────────────┼─────────────────────────────┼────────────────────────────┤
  │ Noise term   │ 1                           │ Σ_m γ_mk                   │
  └──────────────┴─────────────────────────────┴────────────────────────────┘

  Key differences:

  1. Numerator structure: In the downlink, each AP m has its own √η_mk inside
  the sum, giving M×K degrees of freedom for power allocation. In the uplink,
  there is one η_k per user — all APs combine with the same power weight, giving
   only K degrees of freedom.
  2. Noise term: In the downlink, noise is simply 1 (normalized). In the uplink,
   noise is amplified by the matched filter: the combining vector ĝ*_mk
  amplifies noise by |ĝ_mk|², and Σ_m E{|ĝ_mk|²} = Σ_m γ_mk. This noise
  enhancement is the price of matched filtering.
  3. The uplink is structurally simpler — it's a quasi-linear optimization
  problem (solved by bisection + LP), while the downlink is quasi-concave
  (bisection + SOCP).

  4.3 Remark 3 — Reduction to Collocated Massive MIMO

  When all APs are collocated: β_mk = β_k for all m, γ_mk = γ_k, and we set η_mk
   = η_k / (M · γ_k) (equal power split). With orthogonal pilots (|φ^H_k' φ_k|²
  = 0 for k' ≠ k):

  Downlink reduces to:

                                M · ρ_df · η_k · γ_k
  R^cf_{d,k}  →  log₂( 1 + ─────────────────────────── )              ... (25)
                              ρ_df · Σ_{k'} η_k' + 1

  This is exactly the standard collocated Massive MIMO rate from Ngo et al. 2013
   and the textbook by Marzetta et al. This confirms Cell-Free Massive MIMO is a
   strict generalization of collocated Massive MIMO.

  4.4 Remark 4 & Figure 2 — Validating Channel Hardening

  Remark 4 compares two quantities:

  1. Eq. (24) — achievable rate when user knows only channel statistics
  (E{effective channel})
  2. Eq. (26) — genie-aided rate when user knows the exact instantaneous
  effective channel

  Equation (26) is:

  R̃^cf_{d,k} = E{ log₂( 1 + ρ_df · |Σ_m √η_mk · g_mk · ĝ*_mk|² / (ρ_df ·
  Σ_{k'≠k} |Σ_m √η_mk' · g_mk · ĝ*_mk'|² + 1) ) }

  Figure 2 plots both for various M with K = 10 and K = 20:

    Rate
    (bits/s/Hz)
     5 ┤
       │                                    ─── genie-aided (Eq. 26)
     4 ┤                              ·····  ─── statistics only (Eq. 24)
       │                       ···· ─────────
     3 ┤              ···─────────  K=10
       │      ···─────
     2 ┤ ···──────────────────────────────── K=20
       │──────
     1 ┤
       │
     0 ┼───┬───┬───┬───┬───┬───┬───┬───┬──→ M
       20  40  60  80  100 120 140 160 200

  The gap between the two curves is tiny — confirming that:
  - Channel hardening works in Cell-Free MIMO (the effective channel
  concentrates around its mean)
  - Downlink pilots are unnecessary (using only statistics costs almost nothing)
  - Eq. (24) is a tight, practical bound that can be used for system design

  4.5 Remark 5 — Uplink Reduces to Collocated (Sanity Check)

  Similarly, with collocated APs and orthogonal pilots, Eq. (27) reduces to:

                              M · ρ_uf · η_k · γ_k
  R^cf_{u,k}  →  log₂( 1 + ─────────────────────────── )              ... (28)
                             ρ_uf · Σ_{k'} η_k' + 1

  which matches the known collocated Massive MIMO uplink rate from Ngo & Larsson
   2013.

  4.6 Summary: The Complete Rate Analysis Framework

    ┌──────────────────────────────────────────────────────────────┐
    │                    SECTION III SUMMARY                       │
    ├──────────────────────────────────────────────────────────────┤
    │                                                              │
    │  Large-M Analysis (III-A):                                   │
    │  • As M→∞: noise, non-coherent interference, fading → 0     │
    │  • Only pilot contamination survives                         │
    │  • Tool: Tchebyshev's theorem (WLLN for non-i.i.d.)         │
    │                                                              │
    │  Finite-M Analysis (III-B):                                  │
    │  • Use-and-Then-Forget bounding technique                    │
    │  • Signal = DS·q + BU·q + Σ UI·q' + noise                   │
    │  • Worst-case Gaussian noise → capacity lower bound          │
    │                                                              │
    │  Theorem 1 (Downlink):                                       │
    │  • Numerator: ρ_df · (Σ_m √η_mk · γ_mk)²   [coherent gain] │
    │  • Denom: pilot contam. (O(M²)) + BU+UI (O(M)) + noise (1)  │
    │  • Power control: M×K variables η_mk                        │
    │                                                              │
    │  Theorem 2 (Uplink):                                         │
    │  • Numerator: ρ_uf · η_k · (Σ_m γ_mk)²     [coherent gain]  │
    │  • Denom: pilot contam. + interference + noise enhancement   │
    │  • Power control: K variables η_k (simpler)                  │
    │                                                              │
    │  Key Insight: γ_mk is the fundamental building block —       │
    │  it encodes channel quality, pilot contamination, and        │
    │  training investment in one parameter.                       │
    └──────────────────────────────────────────────────────────────┘

  The closed-form SINR depends only on large-scale fading coefficients {β_mk}
  and power control variables {η_mk} — not on instantaneous channel
  realizations. This is what makes max-min power control (Section IV) tractable
  and globally optimal.

  ---
  Ready to move to Section IV (Pilot Assignment and Power Control)?

✻ Churned for 17m 57s